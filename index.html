<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!<!-- Se il file è nella stessa cartella dell'HTML -->
    <script src="jsdiff.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ... (keep all your existing CSS) ... */
        :root {
            --primary: #A5D8FF;
            --secondary: #FFD6A5;
            --accent: #D8A5FF;
            --text: #4A5568;
            --light: #F7FAFC;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #F0F9FF;
            color: var(--text);
        }

        .gradient-bg {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 50%, var(--accent) 100%);
        }

        .text-area {
            min-height: 150px;
            transition: all 0.3s ease;
        }

        .text-area:focus {
            box-shadow: 0 0 0 3px rgba(165, 216, 255, 0.5);
        }

        .btn-primary {
            background-color: var(--primary);
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            background-color: #8BC7FF;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--secondary);
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background-color: #FFC68C;
            transform: translateY(-2px);
        }

        .btn-accent {
            background-color: var(--accent);
            transition: all 0.3s ease;
        }

        .btn-accent:hover {
            background-color: #CA8CFF;
            transform: translateY(-2px);
        }

        .loading-dots::after {
            content: '.';
            animation: dots 1.5s steps(5, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }

        .slide-in {
            animation: slideIn 0.5s ease-out forwards;
        }

        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* NOTE: The diff styles might not be applicable anymore
           as the API won't return structured changes easily */
        .diff-added {
            background-color: rgba(166, 226, 45, 0.3);
            text-decoration: underline;
        }

        .diff-removed {
            background-color: rgba(255, 129, 130, 0.3);
            text-decoration: line-through;
        }
        .correction-item {
    padding: 8px;
    border-left: 3px solid #FFB86C;
    background-color: rgba(255, 184, 108, 0.1);
    margin-bottom: 8px;
}

.correction-original {
    color: #E53E3E;
    text-decoration: line-through;
    font-weight: 500;
}

.correction-corrected {
    color: #38A169;
    font-weight: 500;
}

.correction-explanation {
    margin-top: 4px;
    font-style: italic;
    color: #4A5568;
}

/* Animazione per l'icona del toggle */
.rotate-icon {
    transform: rotate(180deg);
}

/* Animazione per il pannello */
.slide-down {
    max-height: 500px;
    transition: max-height 0.3s ease-in-out;
}

.slide-up {
    max-height: 0;
    transition: max-height 0.3s ease-in-out;
}
.language-detected {
    animation: flash-detection 1s ease-in-out;
}

@keyframes flash-detection {
    0% { background-color: rgba(165, 216, 255, 0); }
    50% { background-color: rgba(165, 216, 255, 0.5); }
    100% { background-color: rgba(165, 216, 255, 0); }
}

.history-item {
    padding: 10px;
    border-left: 3px solid #D8A5FF;
    background-color: rgba(216, 165, 255, 0.1);
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.history-item:hover {
    background-color: rgba(216, 165, 255, 0.2);
    transform: translateX(3px);
}

.history-date {
    font-size: 0.8rem;
    color: #6B7280;
    margin-bottom: 4px;
}

.history-preview {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9rem;
}

.history-selected {
    border-left-color: #8B5CF6;
    background-color: rgba(139, 92, 246, 0.15);
}


    </style>
</head>
<body class="min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-3xl">
        <!-- Header -->
        <header class="mb-8 text-center">
            <div class="gradient-bg roun-full w-20 h-20 flex items-center justify-center mx-auto mb-4">
                <i class="fas fa-magic text-white text-3xl"></i>
            </div>
            <h1 class="text-3xl font-bold text-gray-800 mb-2">EasyFix (Beta)</h1>
            <p class="text-gray-600">✨ Correggi e riformula i tuoi testi grazie all'intelligenza artificiale</p>
        </header>

        <!-- Main Card -->
        <div class="bg-white rounded-xl shadow-lg overflow-hidden mb-8">
            <!-- Tabs -->
            <div class="flex border-b">
                <button id="text-tab" class="flex-1 py-4 px-6 text-center font-medium text-gray-700 border-b-2 border-blue-500">
                    <i class="fas fa-edit mr-2"></i>Testo
                </button>
                <button id="settings-tab" class="flex-1 py-4 px-6 text-center font-medium text-gray-500">
                    <i class="fas fa-cog mr-2"></i>Impostazioni
                </button>
            </div>

            <div class="mb-6 mt-4">
                <button id="history-toggle" class="w-full flex items-center justify-between p-3 bg-purple-50 text-gray-800 rounded-lg border border-purple-200 hover:bg-purple-100 transition-all">
                    <span class="font-medium">Cronologia correzioni</span>
                    <i class="fas fa-history mr-2"></i>
                    <i class="fas fa-chevron-down transition-transform" id="history-toggle-icon"></i>
                </button>
                <div id="history-panel" class="bg-white p-4 rounded-lg border border-purple-200 mt-2 hidden overflow-hidden">
                    <div class="mb-3 text-sm text-gray-600">
                        <p>Seleziona una correzione precedente per visualizzarla:</p>
                    </div>
                    <div id="history-list" class="max-h-60 overflow-y-auto">
                        <!-- Gli elementi della cronologia verranno inseriti qui dinamicamente -->
                        <p class="text-gray-500 text-sm italic" id="no-history-message">Nessuna correzione precedente disponibile.</p>
                    </div>
                </div>
            </div>

            <!-- Text Tab Content -->
            <div id="text-content" class="p-6">
                <div class="mb-6">
                    <label for="input-text" class="block text-sm font-medium text-gray-700 mb-2">Inserisci il tuo testo</label>
                    <textarea id="input-text" class="text-area w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-200" placeholder="Scrivi o incolla qui il testo da correggere..."></textarea>
                </div>

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Opzioni</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- Removed detect-lang as API doesn't directly return it easily -->
                        <!-- <div class="flex items-center">
                            <input type="checkbox" id="detect-lang" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" checked>
                            <label for="detect-lang" class="ml-2 block text-sm text-gray-700">Riconoscimento lingua</label>
                        </div> -->
                        <div class="flex items-center">
                            <input type="checkbox" id="proofreading" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" checked>
                            <label for="proofreading" class="ml-2 block text-sm text-gray-700">Correzione grammaticale</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="rephrase" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                            <label for="rephrase" class="ml-2 block text-sm text-gray-700">Riformulazione</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="style-match" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                            <label for="style-match" class="ml-2 block text-sm text-gray-700">Adatta al mio stile</label>
                        </div>
                    </div>
                </div>

                <div class="flex flex-col sm:flex-row gap-4">
                    <button id="process-btn" class="btn-primary flex-1 py-3 px-6 rounded-lg text-white font-medium flex items-center justify-center">
                        <i class="fas fa-spinner fa-spin hidden mr-2" id="processing-spinner"></i>
                        <span id="process-text">Ottimizza il testo</span>
                    </button>
                    <button id="clear-btn" class="btn-secondary py-3 px-6 rounded-lg text-gray-800 font-medium">
                        <i class="fas fa-trash-alt mr-2"></i>Pulisci
                    </button>
                </div>
            </div>            

            <!-- Settings Tab Content -->
            <div id="settings-content" class="p-6 hidden">
                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-900 mb-4">Profilo di scrittura</h3>
                    <div class="mb-4">
                        <label for="writing-style" class="block text-sm font-medium text-gray-700 mb-2">Descrizione del tuo stile</label>
                        <textarea id="writing-style" class="text-area w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-200" placeholder="Es: Uso un tono formale ma amichevole, con frasi brevi e dirette..."></textarea>
                    </div>
                    <div class="mb-4">
                        <label for="sample-text" class="block text-sm font-medium text-gray-700 mb-2">Testo di esempio del tuo stile</label>
                        <textarea id="sample-text" class="text-area w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-200" placeholder="Incolla un testo scritto da te che rappresenta il tuo stile..."></textarea>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-900 dark:text-gray-100 mb-4">Preferenze</h3>
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <span class="flex-grow flex flex-col">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Lingua preferita</span>
                                <span class="text-xs text-gray-500 dark:text-gray-400">'Automatico' rileva la lingua ad ogni processo</span>
                            </span>
                             <!-- AGGIUNTO 'auto' come PRIMA opzione -->
                            <select id="preferred-lang" class="ml-4 block pl-3 pr-10 py-2 text-base border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
                                <option value="auto" selected>Automatico</option>
                                <option value="it">Italiano</option>
                                <option value="en">Inglese</option>
                                <option value="es">Spagnolo</option>
                                <option value="fr">Francese</option>
                                <option value="de">Tedesco</option>
                                <option value="ru">Russo</option>
                                <option value="pt">Portoghese</option>
                                <option value="ar">Arabo</option> <!-- AGGIUNTA LINGUA ARABO -->
                            </select>                                                        
                        </div>
                        

                        <div class="flex items-center justify-between">
                            <span class="flex-grow flex flex-col">
                                <span class="text-sm font-medium text-gray-700">Tono desiderato</span>
                                <span class="text-xs text-gray-500">Per la riformulazione</span>
                            </span>
                            <select id="default-tone" class="ml-4 block pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                                <option value="neutral">Neutrale</option>
                                <option value="formal">Formale</option>
                                <option value="friendly">Amichevole</option>
                                <option value="professional">Professionale</option>
                                <option value="casual">Informale</option>
                                <option value="sarcastic">Sarcastico</option>
                            </select>
                        </div>
                                                <!-- NUOVO: Selettore Livello Linguistico CEFR -->
                                                <div class="flex items-center justify-between">
                                                    <span class="flex-grow flex flex-col">
                                                        <span class="text-sm font-medium text-gray-700">Livello Linguistico (CEFR)</span>
                                                        <span class="text-xs text-gray-500">Per Riformulazione/Adatta stile</span>
                                                    </span>
                                                    <select id="cefr-level" class="ml-4 block pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md disabled:opacity-50 disabled:cursor-not-allowed bg-white" disabled>
                                                        <option value="none" selected>Nessuno</option>
                                                        <option value="A1">A1 (Principiante)</option>
                                                        <option value="A2">A2 (Elementare)</option>
                                                        <option value="B1">B1 (Intermedio)</option>
                                                        <option value="B2">B2 (Intermedio Sup.)</option>
                                                        <option value="C1">C1 (Avanzato)</option>
                                                        <option value="C2">C2 (Padronanza)</option>
                                                    </select>
                                                </div>
                                                <!-- FINE NUOVO: Selettore Livello Linguistico CEFR -->
                        
                    </div>
                </div>

                <div class="flex justify-end">
                    <button id="save-settings" class="btn-accent py-2 px-6 rounded-lg text-white font-medium">
                        <i class="fas fa-save mr-2"></i>Salva impostazioni
                    </button>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results-section" class="bg-white rounded-xl shadow-lg overflow-hidden hidden slide-in">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-gray-800">Risultati</h2>
                    <div class="flex items-center">
                        <span class="text-sm text-gray-500 mr-2">Lingua (impostata):</span>
                        <span id="detected-lang" class="px-2 py-1 bg-blue-100 text-blue-800 text-xs font-medium rounded">Italiano</span>
                    </div>
                </div>

                <div class="mb-6">
                    <button id="corrections-toggle" class="w-full flex items-center justify-between p-3 bg-blue-50 text-gray-800 rounded-lg border border-blue-200 hover:bg-blue-100 transition-all">
                        <span class="font-medium">Spiegazione delle correzioni</span>
                        <i class="fas fa-chevron-down transition-transform" id="toggle-icon"></i>
                    </button>
                    <div id="corrections-explanation" class="bg-yellow-50 p-4 rounded-lg border border-yellow-200 mt-2 hidden overflow-hidden">
                        <div id="corrections-list" class="space-y-2 max-h-60 overflow-y-auto text-sm">
                            <!-- Le spiegazioni verranno inserite qui dinamicamente -->
                        </div>
                    </div>
                </div>
                

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label class="block text-sm font-medium text-gray-700">Originale (con modifiche evidenziate)</label>
                            <span id="original-count" class="text-xs text-gray-500">0 parole</span>
                        </div>
                        <!-- Modificato per usare innerHTML per l'evidenziazione -->
                        <div id="original-text-highlighted" class="bg-gray-50 p-4 rounded-lg border border-gray-200 h-64 overflow-y-auto whitespace-pre-wrap"></div>
                    </div>

                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label class="block text-sm font-medium text-gray-700">Elaborato dall'AI</label>
                            <span id="corrected-count" class="text-xs text-gray-500">0 parole</span>
                        </div>
                        <div id="corrected-text" class="bg-blue-50 p-4 rounded-lg border border-blue-200 h-64 overflow-y-auto whitespace-pre-wrap"></div>
                    </div>
                </div>

                <!-- Removed Changes List as it's hard to get structured diffs from the API -->
                <!-- <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Modifiche apportate</label>
                    <div id="changes-list" class="space-y-2 max-h-60 overflow-y-auto">
                         <p class="text-gray-500">La visualizzazione dettagliata delle modifiche non è disponibile con l'API diretta.</p>
                    </div>
                </div> -->

                <div class="flex flex-col sm:flex-row gap-4 mt-6">
                    <button id="copy-btn" class="btn-primary flex-1 py-3 px-6 rounded-lg text-white font-medium">
                        <i class="far fa-copy mr-2"></i>Copia testo elaborato
                    </button>
                    <button id="new-text-btn" class="btn-secondary py-3 px-6 rounded-lg text-gray-800 font-medium">
                        <i class="fas fa-redo mr-2"></i>Nuovo testo
                    </button>
                </div>
            </div>
        </div>

        <!-- Info Section -->
        <div class="mt-8 bg-white rounded-xl shadow-lg overflow-hidden">
             <div class="p-6">
                <h2 class="text-xl font-bold text-gray-800 mb-4">Informazioni su EasyFix</h2>
                <div class="prose prose-sm max-w-none text-gray-600">
                    <p>EasyFix utilizza modelli di linguaggio avanzati di Google AI per aiutarti a perfezionare i tuoi testi. Ecco cosa puoi fare:</p>
                    <ul class="list-disc pl-5 mt-2 space-y-1">
                        <li><strong>Correzione grammaticale e ortografica</strong> - Trova e corregge errori nel testo</li>
                        <li><strong>Riformulazione intelligente</strong> - Riscrivi il testo mantenendo il significato ma migliorando lo stile o cambiando tono</li>
                        <li><strong>Adattamento al tuo stile</strong> - Personalizza la riformulazione in base alle tue preferenze e ai tuoi esempi</li>
                    </ul>
                    <p class="mt-4">EasyFix è progettato per essere semplice e intuitivo, con un'interfaccia pulita che funziona perfettamente su dispositivi mobili e desktop.</p>
                </div>
                <div class="mt-6 text-sm text-gray-500">
                    <span>Creato da Mauro Col - 2025 © <br> versione 0.1 </span>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform translate-y-10 opacity-0 transition-all duration-300 flex items-center">
        <i class="fas fa-check-circle mr-2"></i>
        <span id="toast-message">Operazione completata!</span>
    </div>
    <script>
        // Inserisci questo codice DENTRO il tag <script> alla fine del tuo body HTML
    
    // Inserisci questo codice DENTRO il tag <script> alla fine del tuo body HTML

document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM Caricato. Avvio script EasyFix v12 CEFR."); // Version bump

    // --- Elements ---
    // Verifica critica elementi essenziali
    const textTab = document.getElementById('text-tab');
    const settingsTab = document.getElementById('settings-tab');
    const textContent = document.getElementById('text-content');
    const settingsContent = document.getElementById('settings-content');
    const processBtn = document.getElementById('process-btn');
    const inputText = document.getElementById('input-text');
    const resultsSection = document.getElementById('results-section');
    const correctedText = document.getElementById('corrected-text');
    const historyToggleBtn = document.getElementById('history-toggle');
    const historyPanel = document.getElementById('history-panel');
    const preferredLangSelect = document.getElementById('preferred-lang');
    const defaultToneSelect = document.getElementById('default-tone');
    const proofreadingCheck = document.getElementById('proofreading');
    const rephraseCheck = document.getElementById('rephrase');
    const styleMatchCheck = document.getElementById('style-match');
    const writingStyleInput = document.getElementById('writing-style');
    const sampleTextInput = document.getElementById('sample-text');
    const cefrLevelSelect = document.getElementById('cefr-level'); // *** AGGIUNTA ***

    // Log e gestione errori se elementi critici mancano
    const essentialUI = { processBtn, inputText, resultsSection, correctedText, textTab, settingsTab, textContent, settingsContent, historyToggleBtn, historyPanel, preferredLangSelect, defaultToneSelect, proofreadingCheck, rephraseCheck, styleMatchCheck, writingStyleInput, sampleTextInput, cefrLevelSelect }; // *** AGGIUNTA cefrLevelSelect ***
    let missingElements = [];
    for (const [name, el] of Object.entries(essentialUI)) {
        if (!el) {
             console.error(`ERRORE CRITICO AVVIO: Elemento UI essenziale '${name}' NON trovato! Verifica l'ID nell'HTML.`);
              missingElements.push(name);
        }
    }
    if (missingElements.length > 0) {
        alert(`Errore grave: Impossibile trovare elementi UI essenziali (${missingElements.join(', ')}). L'applicazione potrebbe non funzionare.`);
        return; // Ferma se mancano elementi critici
    }

    // Elementi secondari (con check nullità successivi)
    const processingSpinner = document.getElementById('processing-spinner');
    const processText = document.getElementById('process-text');
    const originalTextHighlighted = document.getElementById('original-text-highlighted');
    const detectedLang = document.getElementById('detected-lang');
    const originalCount = document.getElementById('original-count');
    const correctedCount = document.getElementById('corrected-count');
    const clearBtn = document.getElementById('clear-btn');
    const newTextBtn = document.getElementById('new-text-btn');
    const copyBtn = document.getElementById('copy-btn');
    const saveSettings = document.getElementById('save-settings');
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toast-message');
    const correctionsToggleBtn = document.getElementById('corrections-toggle');
    const correctionsExplanationBox = document.getElementById('corrections-explanation');
    const correctionsToggleIcon = document.getElementById('toggle-icon');
    const historyToggleIcon = document.getElementById('history-toggle-icon');
    const styleContainer = writingStyleInput?.closest('.mb-6'); // Usa un container più generale per stile
    const styleDescriptionLabel = document.querySelector('label[for="writing-style"]');
    const styleSampleLabel = document.querySelector('label[for="sample-text"]');

    // --- API Configuration ---
    const API_KEY = "AIzaSyDWnH7YEbBDG3Ph5JLbUyZVS_RBSb4uxgs"; // <-- INSERISCI LA TUA CHIAVE API VALIDA QUI
    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`;
    const SUPPORTED_LANGS = ['it', 'en', 'es', 'fr', 'de', 'ru', 'pt', 'ar'];

    // --- UI Translations ---
    const uiTranslations = { /* ... (invariate v11) ... */
        'it': { processBtn: 'Ottimizza il testo', loading: 'Rilevamento lingua...', success: 'Successo!', error: 'Errore', langDetectError: 'Errore rilev. lingua', processing: 'Elaborazione...', langMismatchError: 'Errore: Lingua risultato non valida!', apiKeyError: 'Errore: Chiave API non valida o mancante', networkError: 'Errore di Rete', unknownError: 'Errore Sconosciuto', noActionError: 'Seleziona almeno Correzione o Riformulazione' },
        'en': { processBtn: 'Optimize text', loading: 'Detecting language...', success: 'Success!', error: 'Error', langDetectError: 'Lang detect error', processing: 'Processing...', langMismatchError: 'Error: Invalid result language!', apiKeyError: 'Error: Invalid or missing API Key', networkError: 'Network Error', unknownError: 'Unknown Error', noActionError: 'Select at least Proofreading or Rephrasing' },
        'ru': { processBtn: 'Оптимизировать текст', loading: 'Определение языка...', success: 'Успех!', error: 'Ошибка', langDetectError: 'Ошибка опр. языка', processing: 'Обработка...', langMismatchError: 'Ошибка: Неверный язык результата!', apiKeyError: 'Ошибка: Неверный или отсутствующий ключ API', networkError: 'Сетевая ошибка', unknownError: 'Неизвестная ошибка', noActionError: 'Выберите хотя бы Исправление или Перефразирование' },
        'pt': { processBtn: 'Otimizar texto', loading: 'Detectando idioma...', success: 'Sucesso!', error: 'Erro', langDetectError: 'Erro det. idioma', processing: 'Processando...', langMismatchError: 'Erro: Idioma do resultado inválido!', apiKeyError: 'Erro: Chave de API inválida ou ausente', networkError: 'Erro de Rede', unknownError: 'Erro Desconhecido', noActionError: 'Selecione pelo menos Revisão ou Reformulação' },
        'de': { processBtn: 'Text optimieren', loading: 'Sprache erkennen...', success: 'Erfolg!', error: 'Fehler', langDetectError: 'Spracherk. Fehler', processing: 'Verarbeitung...', langMismatchError: 'Fehler: Ungültige Ergebnissprache!', apiKeyError: 'Fehler: Ungültiger oder fehlender API-Schlüssel', networkError: 'Netzwerkfehler', unknownError: 'Unbekannter Fehler', noActionError: 'Wählen Sie mindestens Korrekturlesen oder Umformulieren' },
        'fr': { processBtn: 'Optimiser le texte', loading: 'Détection langue...', success: 'Succès!', error: 'Erreur', langDetectError: 'Err détec. langue', processing: 'Traitement...', langMismatchError: 'Erreur : Langue du résultat invalide !', apiKeyError: 'Erreur : Clé API invalide ou manquante', networkError: 'Erreur Réseau', unknownError: 'Erreur Inconnue', noActionError: 'Sélectionnez au moins Correction ou Reformulation' },
        'es': { processBtn: 'Optimizar texto', loading: 'Detectando idioma...', success: '¡Éxito!', error: 'Error', langDetectError: 'Error det. idioma', processing: 'Procesando...', langMismatchError: 'Error: ¡Idioma del resultado inválido!', apiKeyError: 'Error: Clave API inválida o faltante', networkError: 'Error de Red', unknownError: 'Error Desconocido', noActionError: 'Seleccione al menos Corrección o Reformulación' },
        'ar': { processBtn: 'تحسين النص', loading: 'اكتشاف اللغة...', success: 'نجاح!', error: 'خطأ', langDetectError: 'خطأ في اكتشاف اللغة', processing: 'معالجة...', langMismatchError: 'خطأ: لغة النتيجة غير صالحة!', apiKeyError: 'خطأ: مفتاح API غير صالح أو مفقود', networkError: 'خطأ في الشبكة', unknownError: 'خطأ غير معروف', noActionError: 'حدد التدقيق اللغوي أو إعادة الصياغة على الأقل' }
    };

    // --- Funzioni Helper Generiche ---
    function countWords(t){ return t?.trim()===''?0:t.trim().split(/\s+/).length; }
    function getToneDisplayName(c) { /* ... (invariata) ... */ return {formal:'Formale', friendly:'Amichevole', professional:'Professionale', casual:'Informale', sarcastic:'Sarcastico'}[c] || 'Neutrale'; }
    function getLanguageName(c) { /* ... (invariata) ... */ return {it:'Italiano', en:'Inglese', es:'Spagnolo', fr:'Francese', de:'Tedesco', ru:'Russo', pt:'Portoghese', ar:'Arabo'}[c] || 'Sconosciuta'; }
    function detectLanguageLocalSimple(t) { /* ... (invariata) ... */ if (!t) return 'und'; const tl = t.toLowerCase(); if (/[\u0600-\u06FF]/.test(tl)) return 'ar'; if (/[\u0400-\u04FF]/.test(tl)) return 'ru'; if (/[äöüß]/i.test(tl)) return 'de'; if (/[ãõâçêôú]/i.test(tl)) return 'pt'; if (/[ñ¡¿]/i.test(tl)) return 'es'; if (/[àâæçéèêëîïôùûüÿ]/i.test(tl)) return 'fr'; const itM = (tl.match(/\b(il|la|lo|gli|le|del|che|non|sono|hanno|è|per|con|una|si|ciò)\b/g) || []).length; const enM = (tl.match(/\b(the|and|is|are|was|were|have|has|not|for|with|you|that|this|it|of)\b/g) || []).length; if (itM > enM + 2 && itM >= 3) return 'it'; if (enM > itM + 2 && enM >= 3) return 'en'; return 'und'; }
    function calculateWordOverlap(t1, t2) { /* ... (invariata) ... */ if (!t1 || !t2) return 0; const n = (t) => t.toLowerCase().match(/[\p{L}\p{N}]+/gu) || []; const w1 = new Set(n(t1)); const w2 = new Set(n(t2)); if (w1.size === 0) return w2.size === 0 ? 1 : 0; const i = new Set([...w1].filter(x => w2.has(x))); return w1.size > 0 ? i.size / w1.size : (w2.size === 0 ? 1 : 0); }
    function generateExplanation(original, corrected, language) { /* ... (invariata) ... */ const rules = { 'it': { "qual'è": "qual è", "po'": "po’", "perchè": "perché", "sé stesso": "sé stesso", "avvolte":"a volte", "propietario":"proprietario" }, 'ru': { "делаеш": "делаешь", "привет мир":"Привет, мир!", "как дила":"как дела?", "этат":"этот", "ашибками":"ошибками" }, 'en': { "its": "it's", "it's":"its", "your":"you're", "you're":"your", "their":"there", "there":"their", "they're":"their", "helo":"hello", "mistaks":"mistakes", "exemples":"examples"}, 'es': { "ola":"hola", "estas":"estás", "texo":"texto", "herrores":"errores", "como estas":"cómo estás" }, 'fr': { "bonjur":"bonjour", "ca va":"ça va", "érreurs":"erreurs"}, 'de': { "wie gehts":"wie geht's", "feler":"fehler" }, 'pt': { "voce":"você", "esta":"está", "contem":"contém" }, 'ar': {} }; const langRules = rules[language] || {}; const ot = original.trim(); const ct = corrected.trim(); const on = ot.toLowerCase(); const cn = ct.toLowerCase(); for (const [e, f] of Object.entries(langRules)) { if (on === e.toLowerCase() && cn === f.toLowerCase()) { return `Corretto: '${ot}' → '${ct}'.`; } } const ov = calculateWordOverlap(ot, ct); if (on !== cn && Math.abs(ot.length - ct.length) <= 2 && ov > 0.6) return "Correzione ortografica."; if (ot.replace(/\s+/g, '') !== ct.replace(/\s+/g, '')) { const co = on.replace(/[\P{L}\P{N}\s]+/gu, ''); const cc = cn.replace(/[\P{L}\P{N}\s]+/gu, ''); if (co === cc) return "Correzione punteggiatura/spazi."; } if (ov < 0.8 && ov > 0.2) return "Correzione grammaticale / Modifica struttura."; return "Correzione grammaticale/Miglioramento generico."; }
    function getTranslation(key){let cl=preferredLangSelect?preferredLangSelect.value:'auto';if(cl==='auto'){const lcd=Object.keys(uiTranslations).find(c=>getLanguageName(c)===detectedLang?.textContent?.split(' ')[0]);cl=lcd||'it';}return uiTranslations[cl]?.[key]||uiTranslations['it']?.[key]||key;}

    // --- Funzioni Helper UI ---
    function hideExpandablePanels() { /* ... (invariata) ... */ console.log("Nascondo pannelli..."); const ab = document.getElementById('rephrased-analysis-box'); const hp = historyPanel; hideCorrectionsPanel(); if (ab) ab.classList.add('hidden'); if (hp && !hp.classList.contains('hidden')) { hp.classList.add('hidden'); hp.style.maxHeight = '0'; hp.style.padding = '0'; hp.style.marginTop = '0'; hp.style.opacity = '0'; if (historyToggleIcon) historyToggleIcon.classList.remove('rotate-icon'); } }
    function hideCorrectionsPanel() { /* ... (invariata) ... */ if (correctionsExplanationBox) { correctionsExplanationBox.classList.add('hidden'); correctionsExplanationBox.style.maxHeight = '0'; correctionsExplanationBox.style.padding = '0'; correctionsExplanationBox.style.marginTop = '0'; correctionsExplanationBox.style.opacity = '0';} if (correctionsToggleBtn) correctionsToggleBtn.classList.add('hidden'); if (correctionsToggleIcon) correctionsToggleIcon.classList.remove('rotate-icon'); }
    function hideRephraseAnalysisPanel() { /* ... (invariata) ... */ const ab = document.getElementById('rephrased-analysis-box'); if (ab) ab.classList.add('hidden'); }
    function switchTab(aT,iT,aC,iC){/* ... (invariata) ... */ if(!aT||!iT||!aC||!iC){console.error("Err switchTab: elem mancanti.");return;}console.log(`Switch tab: ${aT.id}->${iT.id}`);aT.classList.add('border-blue-500','text-gray-700');aT.classList.remove('text-gray-500','border-transparent');iT.classList.add('text-gray-500','border-transparent');iT.classList.remove('border-blue-500','text-gray-700');aC.classList.remove('hidden');iC.classList.add('hidden');}
    function showToast(m,bgColor='bg-green-500'){ /* ... (invariata - cambiato bg-* di default?) ... */ if(!toast||!toastMessage){console.error("Elem Toast mancanti");return;}console.log(`Toast:"${m}" (bg:${bgColor})`);toastMessage.textContent=m;toast.className=toast.className.replace(/bg-(green|red|yellow)-500/g,'')+` ${bgColor}`;toast.classList.remove('opacity-0','translate-y-10');toast.classList.add('opacity-100','translate-y-0');if(toast.timeoutId)clearTimeout(toast.timeoutId);toast.timeoutId=setTimeout(()=>{toast.classList.remove('opacity-100','translate-y-0');toast.classList.add('opacity-0','translate-y-10');toast.timeoutId=null;},3500);}
    function updateProcessButtonState() { /* ... (invariata) ... */ const isProofreadingActive = proofreadingCheck?.checked ?? false; const isRephrasingActive = rephraseCheck?.checked ?? false; const isActionSelected = isProofreadingActive || isRephrasingActive; if (processBtn) { processBtn.disabled = !isActionSelected; if (!isActionSelected) { processBtn.classList.add('opacity-50', 'cursor-not-allowed'); } else { processBtn.classList.remove('opacity-50', 'cursor-not-allowed'); } } }
    function setLoadingState(isLoading,messageKey='processing'){ /* ... (invariata) ... */ if(!processingSpinner||!processText||!processBtn){console.error("Elem loading mancanti");return;}const m=getTranslation(messageKey);if(isLoading){console.log(`Loading:TRUE (${m})`);if(processingSpinner)processingSpinner.classList.remove('hidden');if(processText)processText.innerHTML=m+'<span class="loading-dots"></span>';processBtn.disabled=true;processBtn.classList.add('opacity-50','cursor-not-allowed');}else{console.log("Loading:FALSE");if(processingSpinner)processingSpinner.classList.add('hidden');if(processText)processText.textContent=getTranslation('processBtn'); updateProcessButtonState(); /* Aggiorna stato bottone al termine */}}

    // *** MODIFICA: Aggiornata per includere il selettore CEFR ***
    function updateStyleOptionsState() {
        const isRephrasing = rephraseCheck?.checked ?? false;
        console.log(`Aggiornamento opzioni Riformulazione (Stile/Livello): ${isRephrasing ? 'Abilitato' : 'Disabilitato'}`);

        // Elementi controllati dalla checkbox "Riformulazione"
        const controlledElements = [writingStyleInput, sampleTextInput, styleMatchCheck, cefrLevelSelect];
        // Etichette/Contenitori da rendere opachi se disabilitati
        const visualContainers = [
            writingStyleInput?.closest('.mb-4'),      // Container descrizione stile
            sampleTextInput?.closest('.mb-4'),        // Container esempio stile
            styleMatchCheck?.closest('.flex'),        // Container checkbox "Adatta stile"
            cefrLevelSelect?.closest('.flex')         // Container select CEFR
        ];

        controlledElements.forEach(el => {
            if (!el) return;
            el.disabled = !isRephrasing; // Abilita/Disabilita l'elemento input/select

            // Se stiamo disabilitando, resetta i valori
            if (!isRephrasing) {
                if (el === styleMatchCheck) el.checked = false;
                if (el === cefrLevelSelect) el.value = 'none';
                // Non resettiamo i textarea, l'utente potrebbe volerli mantenere
            }
        });

        visualContainers.forEach(container => {
            if (!container) return;
            if (isRephrasing) {
                container.classList.remove('opacity-50');
            } else {
                container.classList.add('opacity-50');
            }
        });

         // Assicurati che styleMatchCheck sia gestito correttamente (potrebbe essere ridondante ma sicuro)
         if (styleMatchCheck) {
             styleMatchCheck.disabled = !isRephrasing;
             if (!isRephrasing) styleMatchCheck.checked = false;
         }
    }

    // --- Error Handling ---
    function handleError(context, error, showAlert = false) { /* ... (invariata) ... */ console.error(`Errore in ${context}:`, error); let message = error?.message || getTranslation('unknownError'); let specificKeyError = false; let isMismatchError = false; if (message.includes("API key not valid") || message.includes("API_KEY") || (message.includes("400") && (message.includes("API key") || message.includes("api_key")))) { message = getTranslation('apiKeyError'); specificKeyError = true; } else if (message.includes("NetworkError") || message.includes("Failed to fetch") || message.includes("Errore di rete")) { message = getTranslation('networkError'); } else if (message.includes("Lingua risultato non valida") || message.includes("Result language mismatch") || message.includes("Invalid result language")) { message = getTranslation('langMismatchError'); isMismatchError = true; } else if (message.startsWith('Errore API')) { message = `Errore API (${context}): ${message.replace('Errore API ','')}`; } else { message = `${getTranslation('error')} (${context}): ${message}`; } showToast(message, 'bg-red-500'); if (showAlert || specificKeyError) { alert(`ERRORE CRITICO:\n${message}\n\nVerifica chiave API e impostazioni progetto.`); } setLoadingState(false); if (resultsSection) resultsSection.classList.remove('hidden'); if (correctedText) correctedText.textContent = `Errore: ${error.message}`; try { hideExpandablePanels(); } catch(e) { console.error("Errore durante hideExpandablePanels in handleError:", e); } }

    // --- Event Listeners ---
    if (textTab && settingsTab && textContent && settingsContent) { textTab.addEventListener('click', () => switchTab(textTab, settingsTab, textContent, settingsContent)); settingsTab.addEventListener('click', () => switchTab(settingsTab, textTab, settingsContent, textContent)); console.log("Listeners Tab aggiunti."); } else { console.error("Errore critico: Elementi Tab mancanti!"); }
    if (correctionsToggleBtn && correctionsExplanationBox && correctionsToggleIcon) { /* ... (invariata) ... */ correctionsToggleBtn.addEventListener('click', function() { console.log("Corrections Toggle clicked."); correctionsToggleIcon.classList.toggle('rotate-icon'); const iH = correctionsExplanationBox.classList.toggle('hidden'); correctionsExplanationBox.style.transition='max-height .3s ease-out,padding .3s ease-out,margin .3s ease-out,opacity .3s ease-out'; if(!iH){correctionsExplanationBox.style.paddingTop='1rem';correctionsExplanationBox.style.paddingBottom='1rem';correctionsExplanationBox.style.marginTop='.5rem';correctionsExplanationBox.style.opacity='1';correctionsExplanationBox.style.maxHeight=(correctionsExplanationBox.scrollHeight+20)+"px";}else{correctionsExplanationBox.style.maxHeight='0';correctionsExplanationBox.style.paddingTop='0';correctionsExplanationBox.style.paddingBottom='0';correctionsExplanationBox.style.marginTop='0';correctionsExplanationBox.style.opacity='0';} }); console.log("Listener Corrections Toggle aggiunto."); } else { console.warn("Warn: Elementi Corrections Toggle mancanti!"); }
    if (historyToggleBtn && historyPanel && historyToggleIcon) { /* ... (invariata) ... */ historyToggleBtn.addEventListener('click', function() { console.log("History Toggle clicked."); historyToggleIcon.classList.toggle('rotate-icon'); const iH = historyPanel.classList.toggle('hidden'); historyPanel.style.transition='max-height .3s ease-out,padding .3s ease-out,margin .3s ease-out,opacity .3s ease-out'; if(!iH){loadHistoryItems();historyPanel.style.padding='1rem';historyPanel.style.marginTop='.5rem';historyPanel.style.opacity='1';setTimeout(()=>{historyPanel.style.maxHeight='300px';},50);}else{historyPanel.style.maxHeight='0';historyPanel.style.padding='0';historyPanel.style.marginTop='0';historyPanel.style.opacity='0';} }); console.log("Listener History Toggle aggiunto."); } else { console.error("Errore critico: Elementi History Toggle mancanti!"); }
    if (rephraseCheck) { rephraseCheck.addEventListener('change', updateStyleOptionsState); console.log("Listener Rephrase Check (per stile/livello) aggiunto."); } else { console.warn("Warn: rephraseCheck mancante."); } // *** AGGIORNATO COMMENTO ***
    if (proofreadingCheck && rephraseCheck && processBtn) { proofreadingCheck.addEventListener('change', updateProcessButtonState); rephraseCheck.addEventListener('change', updateProcessButtonState); console.log("Listeners Checkbox (per bottone) aggiunti."); } else { console.warn("Warn: Checkbox o processBtn mancanti per gestione stato bottone."); }
    if (processBtn) { processBtn.addEventListener('click', handleProcessClick); console.log("Listener Process Button aggiunto."); }
    if (clearBtn) { /* ... (invariata) ... */ clearBtn.addEventListener('click', () => { console.log("Clear Button clicked"); if(inputText) inputText.value = ''; if(resultsSection) resultsSection.classList.add('hidden'); if(originalTextHighlighted) originalTextHighlighted.textContent = ''; if(correctedText) correctedText.textContent = ''; if(originalCount) originalCount.textContent = '0 parole'; if(correctedCount) correctedCount.textContent = '0 parole'; hideExpandablePanels(); updateProcessButtonState(); }); console.log("Listener Clear Button aggiunto."); } else { console.warn("Warn: clear-btn mancante."); }
    if (newTextBtn) { /* ... (invariata) ... */ newTextBtn.addEventListener('click', () => { console.log("New Text Button clicked"); if(inputText) inputText.value = ''; if(resultsSection) resultsSection.classList.add('hidden'); if(originalTextHighlighted) originalTextHighlighted.textContent = ''; if(correctedText) correctedText.textContent = ''; if(originalCount) originalCount.textContent = '0 parole'; if(correctedCount) correctedCount.textContent = '0 parole'; hideExpandablePanels(); inputText?.focus(); updateProcessButtonState(); }); console.log("Listener New Text Button aggiunto."); } else { console.warn("Warn: new-text-btn mancante."); }
    function copyTextToClipboard(t){if(!t){showToast('Nessun testo da copiare','bg-yellow-500');return;}if(navigator.clipboard&&window.isSecureContext){navigator.clipboard.writeText(t).then(()=>showToast('Testo copiato!')).catch(e=>{console.error("Err Clipboard API:",e);fallbackCopyMethod(t);});}else{fallbackCopyMethod(t);}} function fallbackCopyMethod(t){try{const ta=document.createElement("textarea");ta.value=t;ta.style.position="fixed";ta.style.opacity="0";document.body.appendChild(ta);ta.focus();ta.select();const ok=document.execCommand('copy');document.body.removeChild(ta);if(ok)showToast('Testo copiato!');else showToast('Copia fallita','bg-red-500');}catch(e){handleError("fallbackCopy",e);}} if(copyBtn){copyBtn.addEventListener('click',()=>copyTextToClipboard(correctedText?.textContent||''));console.log("Listener Copy Btn aggiunto.");}else{console.warn("Warn: copy-btn mancante.");}
    if(saveSettings) {
        saveSettings.addEventListener('click', () => {
            console.log("Save Settings clicked");
            try {
                const p = {
                    lang: preferredLangSelect?.value || 'auto',
                    tone: defaultToneSelect?.value || 'neutral',
                    cefr: cefrLevelSelect?.value || 'none', // *** AGGIUNTA cefr ***
                    proofread: proofreadingCheck?.checked,
                    rephrase: rephraseCheck?.checked,
                    matchStyle: styleMatchCheck?.checked
                };
                localStorage.setItem('textai-prefs', JSON.stringify(p));
                showToast('Impostazioni salvate!');
            } catch (e) {
                handleError("saveSettings", new Error("Impossibile salvare preferenze."), false); // Non mostrare alert per questo
            }
            if (textTab && settingsTab && textContent && settingsContent) {
                switchTab(textTab, settingsTab, textContent, settingsContent); // Torna alla tab testo dopo salvataggio
            }
        });
        console.log("Listener Save Settings aggiunto.");
    } else { console.warn("Warn: save-settings mancante."); }

    // --- Funzioni Core ---
    async function detectLanguageWithGeminiAPI(text){ /* ... (invariata) ... */ console.log("Chiamo API per rilevare lingua...");const pL=preferredLangSelect?(preferredLangSelect.value!=='auto'?preferredLangSelect.value:'it'):'it';if(!API_KEY||API_KEY.includes("YOUR_API")||API_KEY.length<20){console.error("Chiave API mancante/non valida per rilevamento.");return pL;}if(!text||text.trim().length<10){console.log("Testo breve, uso pref:",pL);return pL;}const pr=`Identify the main language (ISO 639-1 code) from [${SUPPORTED_LANGS.join(', ')}] for: "${text.substring(0,500)}"... Respond ONLY with the 2-letter code or 'und'.`;const req={contents:[{parts:[{text:pr}]}],generationConfig:{temperature:0.0,maxOutputTokens:5,stopSequences:["\n"]}};try{const res=await fetch(API_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(req)});if(!res.ok){let eD='';try{const d=await res.json();eD=d?.error?.message||JSON.stringify(d);}catch{eD=await res.text();}console.warn(`Warn API rilevamento (${res.status}): ${eD}. Uso fallback: ${pL}`);return pL;}const data=await res.json();const code=data.candidates?.[0]?.content?.parts?.[0]?.text?.trim().toLowerCase().match(/^[a-z]{2}$/)?.[0];console.log("API rilevato:",code);if(code&&SUPPORTED_LANGS.includes(code))return code;console.warn("Codice API non valido/supportato, fallback a pref:",pL);return pL;}catch(e){console.error("Errore rete rilevamento:",e);console.warn("Uso fallback:",pL);return pL;}}
    function setDetectedLanguageUI(lc){ /* ... (invariata) ... */ if(!lc||!SUPPORTED_LANGS.includes(lc)){lc='it';}const ln=getLanguageName(lc);if(detectedLang){detectedLang.textContent=ln;detectedLang.classList.remove('language-detected');void detectedLang.offsetWidth;detectedLang.classList.add('language-detected');}if(preferredLangSelect&&preferredLangSelect.value!=='auto'&&preferredLangSelect.value!==lc){console.log(`Aggiorno dropdown (non auto) a: ${lc}`);preferredLangSelect.value=lc;}else if(preferredLangSelect&&preferredLangSelect.value==='auto'&&detectedLang){detectedLang.textContent=`${ln} (Auto)`;}}
    function displayRephraseAnalysis(tone, explanationText, alternatives) { /* ... (invariata) ... */ let analysisBox = document.getElementById('rephrased-analysis-box'); if (!analysisBox) { analysisBox = document.createElement('div'); analysisBox.id = 'rephrased-analysis-box'; analysisBox.className = 'bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-700 rounded-lg p-4 mt-6 mb-8'; analysisBox.innerHTML = `<h3 id="rephrased-analysis-title" class="text-lg font-medium text-blue-800 dark:text-blue-200 mb-3"></h3><div class="mb-4 p-3 bg-white dark:bg-gray-800 rounded-lg border border-blue-200 dark:border-blue-600"><h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Motivazione:</h4><div id="explanation-content" class="text-gray-600 dark:text-gray-400 text-sm"></div></div><div><h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Alternative (Stesso Tono):</h4><div id="alternatives-list" class="space-y-2"></div></div>`; if (resultsSection && resultsSection.parentNode) resultsSection.parentNode.insertBefore(analysisBox, resultsSection.nextSibling); else console.error("Impossibile inserire box analisi."); } const analysisTitle = document.getElementById('rephrased-analysis-title'); if (analysisTitle) analysisTitle.textContent = `Analisi Riformulazione (Tono: ${getToneDisplayName(tone)})`; const explanationContent = document.getElementById('explanation-content'); if (explanationContent) explanationContent.textContent = explanationText || "N/A."; const alternativesList = document.getElementById('alternatives-list'); if (alternativesList && alternatives && alternatives.length > 0) { alternativesList.innerHTML = ''; let validAlternativesFound = 0; alternatives.forEach((alternative) => { if (!alternative || alternative.toLowerCase() === "n/a") return; validAlternativesFound++; const item = document.createElement('div'); item.className = 'p-2 bg-gray-50 dark:bg-gray-700 rounded border border-gray-200 dark:border-gray-600 flex justify-between items-center cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900 transition-colors'; item.dataset.alternativeItem = 'true'; const txt = document.createElement('div'); txt.className = 'flex-grow mr-2 text-sm text-gray-800 dark:text-gray-200'; txt.textContent = alternative; const btn = document.createElement('button'); btn.className = 'text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 text-xs flex items-center flex-shrink-0 ml-2'; btn.innerHTML = `<svg class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z"></path></svg> Copia`; btn.addEventListener('click', (e) => { e.stopPropagation(); copyTextToClipboard(alternative); }); item.appendChild(txt); item.appendChild(btn); item.addEventListener('click', () => { if(correctedText) correctedText.textContent = alternative; if(correctedCount) correctedCount.textContent = countWords(alternative) + ' parole'; alternativesList.querySelectorAll('[data-alternative-item="true"]').forEach(i => i.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'border-blue-300', 'dark:border-blue-500')); item.classList.add('bg-blue-100', 'dark:bg-blue-900', 'border-blue-300', 'dark:border-blue-500'); }); alternativesList.appendChild(item); }); if (validAlternativesFound === 0) alternativesList.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">Nessuna alternativa valida.</p>'; } else if (alternativesList) alternativesList.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">N/A.</p>'; if(analysisBox) analysisBox.classList.remove('hidden'); }
    function displayDifferences(original, result, language, isRephraseResult) { /* ... (invariata) ... */ const cl = document.getElementById('corrections-list'); const ct = correctionsToggleBtn; if (!cl || !originalTextHighlighted) { console.error("Elementi Diff mancanti"); if(originalTextHighlighted) originalTextHighlighted.textContent = original; return; } cl.innerHTML = ''; let cc = 0; hideCorrectionsPanel(); if (typeof Diff === 'undefined') { if(originalTextHighlighted) originalTextHighlighted.textContent = original; return; } const diff = Diff.diffWords(original, result, { ignoreWhitespace: false }); let oHTML = ''; diff.forEach((p) => { const eV = p.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/\n/g, '<br>'); if (p.removed) { oHTML += `<span class="diff-removed">${eV}</span>`; if (p.added) { if (!isRephraseResult) { let eD = generateExplanation(p.removed, p.added, language); const i = document.createElement('div'); i.className = 'correction-item p-2 border-l-2 border-yellow-400 dark:border-yellow-600 mb-1 bg-yellow-50 dark:bg-yellow-900/20'; i.innerHTML = `<div><span class="correction-original text-red-600 dark:text-red-400 line-through">${p.removed}</span> → <span class="correction-corrected text-green-700 dark:text-green-400 font-medium">${p.added}</span></div><div class="correction-explanation text-xs text-gray-500 dark:text-gray-400 mt-1">${eD}</div>`; cl.appendChild(i); } cc++; } else { if (!isRephraseResult) { const i = document.createElement('div'); i.className = 'correction-item p-2 border-l-2 border-red-400 dark:border-red-600 mb-1 bg-red-50 dark:bg-red-900/20'; i.innerHTML = `<div><span class="correction-original text-red-600 dark:text-red-400 line-through">${p.removed}</span></div><div class="correction-explanation text-xs text-gray-500 dark:text-gray-400 mt-1">Testo rimosso.</div>`; cl.appendChild(i); } cc++; } } else if (p.added) { oHTML += `<span class="diff-added" style="background-color: rgba(16, 185, 129, 0.2); padding: 1px 0;">${eV}</span>`; if (!isRephraseResult) { const i = document.createElement('div'); i.className = 'correction-item p-2 border-l-2 border-green-400 dark:border-green-600 mb-1 bg-green-50 dark:bg-green-900/20'; i.innerHTML = `<div><span class="correction-corrected text-green-700 dark:text-green-400 font-medium">${p.added}</span></div><div class="correction-explanation text-xs text-gray-500 dark:text-gray-400 mt-1">Testo aggiunto.</div>`; cl.appendChild(i); } cc++; } else { oHTML += eV; } }); if (originalTextHighlighted) originalTextHighlighted.innerHTML = oHTML; if (!isRephraseResult && cc > 0) { if(ct) ct.classList.remove('hidden'); } }

    // *** MODIFICA: Aggiunto parametro cefrLevel (cl) ***
    function saveToHistory(ot, ct, ir, t, ex, al, cl) {
        try {
            let h = JSON.parse(localStorage.getItem('textai-history') || '[]');
            if (!Array.isArray(h)) h = [];
            // Non includere cl nel controllo duplicati per semplicità ora
            const d = h.some(i => i.originalText === ot && i.correctedText === ct && i.isRephrase === ir && i.tone === t);
            if (!d) {
                const hi = {
                    id: Date.now(),
                    date: new Date().toLocaleString('it-IT'),
                    originalText: ot,
                    correctedText: ct,
                    isRephrase: ir,
                    tone: t,
                    explanation: ex,
                    alternatives: al,
                    cefrLevel: cl, // Salva il livello CEFR
                    preview: ct.substring(0, 60) + (ct.length > 60 ? '...' : '')
                };
                h.unshift(hi);
                if (h.length > 15) h = h.slice(0, 15); // Limita cronologia
                localStorage.setItem('textai-history', JSON.stringify(h));
                console.log("Salvataggio crono:", hi.id, "CEFR:", cl);
            } else {
                console.log("Duplicato non salvato.");
            }
            const hp = historyPanel;
            // Aggiorna vista se pannello è aperto
            if (hp && !hp.classList.contains('hidden')) {
                 loadHistoryItems();
            }
        } catch (error) {
            handleError("saveToHistory", error);
        }
    }

    function loadHistoryItems() { /* ... (invariata - la preview non mostra CEFR) ... */ try { const hl = document.getElementById('history-list'); const nhm = document.getElementById('no-history-message'); if (!hl) { console.error("history-list mancante!"); return; } let h = []; try { h = JSON.parse(localStorage.getItem('textai-history') || '[]'); } catch { console.error("Errore parsing crono"); } if (!Array.isArray(h)) h = []; hl.innerHTML = ''; const msg = nhm || document.getElementById('no-history-message'); if (h.length === 0) { console.log("Crono vuota."); if (msg) { msg.style.display = 'block'; if (!msg.parentNode) hl.appendChild(msg); } else { const n = document.createElement('p'); n.id = 'no-history-message'; n.className = 'text-gray-500 dark:text-gray-400 text-sm italic px-4 py-2'; n.textContent = 'Nessuna correzione.'; hl.appendChild(n); } } else { console.log(`Carico ${h.length} el. crono.`); if (msg) msg.style.display = 'none'; h.forEach(i => { const hi = document.createElement('div'); hi.className = 'history-item p-3 border-b border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer transition-colors'; hi.dataset.id = i.id; hi.innerHTML = `<div class="text-xs text-gray-500 dark:text-gray-400 mb-1">${i.date}</div><div class="text-sm font-medium text-gray-800 dark:text-gray-200 truncate">${i.isRephrase ? `<span class="text-blue-500 font-semibold">[${getToneDisplayName(i.tone)}${i.cefrLevel && i.cefrLevel !== 'none' ? ` / ${i.cefrLevel.toUpperCase()}` : ''}]</span> ` : ''}${i.preview}</div>`; hi.addEventListener('click', () => loadHistoryItem(i.id)); hl.appendChild(hi); }); } } catch (error) { handleError("loadHistoryItems", error); } }

    // *** MODIFICA: Aggiunto parametro cefrLevel (cl) ***
    function loadHistoryItem(id) {
        try {
            console.log(`Carico crono ID: ${id}`);
            let h = JSON.parse(localStorage.getItem('textai-history') || '[]');
            const item = h.find(it => it.id == id);
            if (!item) throw new Error("Elemento cronologia non trovato");

            if (inputText) inputText.value = item.originalText;
            // Evidenzia l'elemento selezionato nella lista
            document.querySelectorAll('.history-item').forEach(el => {
                 el.classList.remove('history-selected', 'bg-blue-100', 'dark:bg-blue-900'); // Rimuovi classi da tutti
                 if (el.dataset.id == id) {
                     el.classList.add('history-selected', 'bg-blue-100', 'dark:bg-blue-900'); // Aggiungi al selezionato
                 }
            });

            // Chiama la funzione per visualizzare i dettagli, passando tutti i dati
            handleHistorySelection(
                item.originalText,
                item.correctedText,
                item.isRephrase,
                item.tone,
                item.explanation,
                item.alternatives,
                item.cefrLevel // Passa il livello CEFR
            );

             // Opzionale: aggiorna i controlli UI per riflettere l'elemento caricato
             if(rephraseCheck) rephraseCheck.checked = item.isRephrase;
             if(defaultToneSelect && item.tone) defaultToneSelect.value = item.tone;
             if(cefrLevelSelect && item.cefrLevel) cefrLevelSelect.value = item.cefrLevel;
             updateStyleOptionsState(); // Aggiorna abilitazione/disabilitazione controlli
             updateProcessButtonState(); // Aggiorna stato bottone principale

        } catch (error) {
            handleError("loadHistoryItem", error);
        }
    }

    // *** MODIFICA: Aggiunto parametro cefrLevel (cl) ***
    async function handleHistorySelection(ot, ctv, ir, tn, ex, al, cl) {
        try {
            console.log("Visualizzo da crono:", { ir, tn, cl }); // Logga anche CEFR
            hideExpandablePanels();
            if(resultsSection) resultsSection.classList.remove('hidden');
            if (originalTextHighlighted) originalTextHighlighted.textContent = ot;
            if (correctedText) correctedText.textContent = ctv;
            if (originalCount) originalCount.textContent = countWords(ot) + ' parole';
            if (correctedCount) correctedCount.textContent = countWords(ctv) + ' parole';

            // Rileva lingua (necessario per displayDifferences)
            let lang = preferredLangSelect ? (preferredLangSelect.value !== 'auto' ? preferredLangSelect.value : 'it') : 'it';
            try {
                const d = await detectLanguageWithGeminiAPI(ot);
                if (d && SUPPORTED_LANGS.includes(d)) lang = d;
            } catch(langErr) {
                 console.warn("Errore rilevamento lingua per history item:", langErr);
            }
            setDetectedLanguageUI(lang);

            displayDifferences(ot, ctv, lang, ir);
            const ab = document.getElementById('rephrased-analysis-box');
            const ctg = correctionsToggleBtn;

            if (ir) {
                // Mostra analisi riformulazione (non mostra CEFR per ora, ma potrebbe)
                displayRephraseAnalysis(tn, ex, al);
                if (ab) ab.classList.remove('hidden');
                hideCorrectionsPanel(); // Nascondi correzioni se è riformulazione
            } else {
                if (ab) ab.classList.add('hidden'); // Nascondi analisi se non è riformulazione
                const clist = document.getElementById('corrections-list');
                // Mostra/nascondi sezione correzioni basata su contenuto effettivo
                if (clist && ctg && clist.children.length > 0) {
                    ctg.classList.remove('hidden');
                } else {
                    hideCorrectionsPanel();
                }
            }
        } catch (error) {
            handleError("handleHistorySelection", error);
        }
    }

    // Funzione per elaborare testo con AI
    // *** MODIFICA: Aggiornato prompt per includere livello CEFR ***
    async function processTextWithAI(text, language, useProofreading, useRephrasing) {
        if (!API_KEY || API_KEY.includes("YOUR_API") || API_KEY.length < 20) {
            throw new Error("Chiave API mancante o non valida.");
        }

        const isStyleMatch = useRephrasing && styleMatchCheck ? styleMatchCheck.checked : false;
        const styleDesc = useRephrasing && writingStyleInput ? writingStyleInput.value.trim() : '';
        const styleSample = useRephrasing && sampleTextInput ? sampleTextInput.value.trim() : '';
        const tone = useRephrasing && defaultToneSelect ? defaultToneSelect.value : 'neutral';
        // *** NUOVO: Recupera livello CEFR selezionato (solo se rilevante) ***
        const cefrLevel = useRephrasing && cefrLevelSelect && cefrLevelSelect.value !== 'none'
                          ? cefrLevelSelect.value
                          : null;

        const langName = getLanguageName(language);
        console.log("Opzioni effettive Prompt:", { useProofreading, useRephrasing, isStyleMatch, tone, cefrLevel });

        let promptBase = `Sei un esperto linguista ${langName}.\n\n`;
        let expectedFormatInstructions = "";
        let genConfigParams = {};

        if (useRephrasing) {
            // --- PROMPT RIFORMULAZIONE (v8 - Aggiunto CEFR) ---
            promptBase += `COMPITO: 1) CORREGGI errori grammaticali/ortografici, POI 2) RIFORMULA il testo CORRETTO usando SOLO ${langName} (${language}).\nISTRUZIONI IMPERATIVE:\n1. LINGUA: Produci output ESCLUSIVAMENTE in ${langName.toUpperCase()}.\n2. CORREZIONE PRIMA: Correggi TUTTI gli errori oggettivi (grammatica, ortografia, punteggiatura) del testo originale PRIMA di riformulare.\n3. RIFORMULA + TONO (${tone.toUpperCase()}): Applica il tono richiesto in modo CHIARO ed EVIDENTE. Riscrivi significativamente la struttura delle frasi e il lessico, non fare solo piccole modifiche.\n`;

            // *** NUOVO: Istruzione CEFR Condizionale ***
            let instructionNumber = 4;
            if (cefrLevel) {
                promptBase += `${instructionNumber}. LIVELLO LINGUISTICO (CEFR ${cefrLevel.toUpperCase()}): Adatta la complessità grammaticale e lessicale al livello CEFR '${cefrLevel}'. Usa strutture di frase e vocabolario appropriati per una persona a quel livello di competenza linguistica. Esempio: A1/A2 = frasi molto semplici, vocabolario base; B1/B2 = frasi più complesse, vocabolario intermedio; C1/C2 = linguaggio ricco, sfumato e complesso.\n`;
                instructionNumber++;
            }

            promptBase += `${instructionNumber}. SIGNIFICATO: Preserva il significato fondamentale e tutte le informazioni chiave del testo originale.\n`;
            instructionNumber++;

            promptBase += `${instructionNumber}. DEFINIZIONE TONI:\n   - Formal: Linguaggio elevato, impersonale, evita contrazioni.\n   - Friendly: Tono caloroso, positivo, amichevole, più colloquiale.\n   - Professional: Chiaro, conciso, autorevole, focalizzato sull'obiettivo.\n   - Casual: Rilassato, informale, come parleresti con un amico.\n   - Sarcastic: Usa ironia evidente, possibilmente esagerata, per esprimere il contrario di ciò che dici letteralmente.\n   - Neutral: Oggettivo, diretto, senza carica emotiva.\n`;
            instructionNumber++;

            if (isStyleMatch && (styleDesc || styleSample)) {
                promptBase += `${instructionNumber}. STILE PERSONALE (Prioritario): Adatta l'output allo stile descritto ("${styleDesc}") e/o esemplificato ("${styleSample}"). COMBINA lo stile personale richiesto con il TONO (${tone.toUpperCase()})${cefrLevel ? ` e il livello LINGUISTICO (CEFR ${cefrLevel.toUpperCase()})` : ''}.\n\n`;
            } else {
                promptBase += "\n";
            }

            // *** NUOVO: Aggiornato formato per menzionare CEFR se attivo ***
            expectedFormatInstructions = `
FORMATO RISPOSTA OBBLIGATORIO (USA SEPARATORI ESATTI IN ${langName.toUpperCase()}):\n
---TESTO_RIFORMULATO_START---
[QUI VA **SOLO ED ESCLUSIVAMENTE** il testo principale RIFORMULATO nel tono ${tone.toUpperCase()}${cefrLevel ? ` e livello CEFR ${cefrLevel.toUpperCase()}` : ''} richiesto. **IMPORTANTE: NON AGGIUNGERE NESSUNA ETICHETTA** come "${tone.toUpperCase()}:", "**TONO:**", "**CEFR:**" o simili all'inizio di questo blocco. Inizia direttamente con il testo riformulato.]
---TESTO_RIFORMULATO_END---

---SPIEGAZIONE_START---
[Spiegazione MOLTO BREVE (1-2 frasi) in ${langName} sulle scelte chiave di riformulazione fatte per ottenere il tono${cefrLevel ? ` e il livello CEFR ${cefrLevel.toUpperCase()}` : ''} richiesti.]
---SPIEGAZIONE_END---

---ALTERNATIVE_START---
[QUI 3 alternative CONCISE e DIVERSE, TUTTE NEL TONO ${tone.toUpperCase()}${cefrLevel ? ` e livello CEFR ${cefrLevel.toUpperCase()}` : ''}. Numera 1. 2. 3. **NON** usare etichette di tono o livello qui.]
1. [Alternativa 1 nel tono ${tone.toUpperCase()}${cefrLevel ? ` (Livello ${cefrLevel.toUpperCase()})` : ''}]
2. [Alternativa 2 nel tono ${tone.toUpperCase()}${cefrLevel ? ` (Livello ${cefrLevel.toUpperCase()})` : ''}]
3. [Alternativa 3 nel tono ${tone.toUpperCase()}${cefrLevel ? ` (Livello ${cefrLevel.toUpperCase()})` : ''}]
---ALTERNATIVE_END---`;

            // Aumenta leggermente la temperatura per più creatività nella riformulazione
             genConfigParams = { temperature: (tone === 'sarcastic') ? 0.95 : 0.85, topP: 0.95, topK: 40 };

        } else if (useProofreading) {
            // --- PROMPT SOLA CORREZIONE (Invariato) ---
            promptBase += `COMPITO: Correggi SOLO errori oggettivi (grammatica, ortografia, punteggiatura) nel testo in ${langName}.\nREGOLE IMPERATIVE:\n1. LINGUA OUTPUT: Esclusivamente ${langName.toUpperCase()} (${language}).\n2. NON MODIFICARE: Non cambiare stile, tono, scelta delle parole o struttura delle frasi se non strettamente necessario per la correzione.\n3. NON RIFORMULARE.\n4. MINIMALISMO: Applica solo le correzioni indispensabili.\n\n`;
            expectedFormatInstructions = `FORMATO RISPOSTA: Fornisci SOLO il testo corretto in ${langName}. Non aggiungere spiegazioni, commenti o altro testo.`;
            // Bassa temperatura per output deterministico
            genConfigParams = { temperature: 0.0, topP: 0.7, topK: 10 };
        } else {
            // Questo caso non dovrebbe accadere grazie ai controlli UI, ma per sicurezza:
            throw new Error("Nessuna azione specificata per l'AI (né correzione né riformulazione).");
        }

        promptBase += `TESTO ORIGINALE DA ELABORARE (${langName}):\n\`\`\`\n${text}\n\`\`\`\n\nLA TUA RISPOSTA IN ${langName.toUpperCase()} (SEGUI ESATTAMENTE IL FORMATO RICHIESTO):${expectedFormatInstructions}`;

        const systemPrompt = promptBase;
        console.log("Prompt (prime 500 char):", systemPrompt.substring(0, 500) + "...");

        // Calcola maxOutputTokens in modo più dinamico
        const baseTokens = 300; // Base per overhead e istruzioni
        const multiplier = useRephrasing ? 3.5 : 1.2; // Riformulazione richiede più spazio
        const estimatedInputTokens = Math.floor(text.length / 3); // Stima grossolana
        const calculatedMaxTokens = Math.max(400, Math.floor(baseTokens + estimatedInputTokens * multiplier));
        const finalMaxTokens = Math.min(8000, calculatedMaxTokens); // Limite massimo assoluto

        const requestBody = {
            contents: [{ parts: [{ text: systemPrompt }] }],
            generationConfig: {
                ...genConfigParams,
                maxOutputTokens: finalMaxTokens // Usa il valore calcolato
            }
        };
        console.log("Generation Config:", requestBody.generationConfig);

        try {
            const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            console.log(`API Status: ${response.status} ${response.statusText}`);
            if (!response.ok) { let eD = `Status: ${response.status}. `; try { const d = await response.json(); eD += d?.error?.message || JSON.stringify(d); } catch { try {eD += await response.text();} catch {} } console.error("API Error Details:", eD); throw new Error(`Errore API. ${eD}`); }

            const data = await response.json();
            const candidate = data.candidates?.[0];
            const finishReason = candidate?.finishReason;
            const blockReason = data.promptFeedback?.blockReason;
            const safetyRatings = JSON.stringify(candidate?.safetyRatings || data.promptFeedback?.safetyRatings || {});

            if (blockReason) throw new Error(`Bloccato (${blockReason}). Ratings: ${safetyRatings}`);
            // Considera MAX_TOKENS un errore potenziale solo se non abbiamo ottenuto testo
            if (finishReason && finishReason !== "STOP" && !(finishReason === "MAX_TOKENS" && candidate?.content?.parts?.[0]?.text)) {
                 throw new Error(`Interrotto (${finishReason}). Ratings: ${safetyRatings}`);
            }

            let generatedText = candidate?.content?.parts?.[0]?.text?.trim();
            if (!generatedText) throw new Error("Risposta API vuota o contenuto mancante.");

            console.log("Testo grezzo AI:\n", generatedText.substring(0, 500) + (generatedText.length > 500 ? "..." : ""));

            // **** PARSING E PULIZIA (v8 - Gestisce CEFR nel ritorno) ****
            if (useRephrasing) {
                let rephrasedText = ''; let explanation = ''; let alternatives = [];
                const textMatch = generatedText.match(/---TESTO_RIFORMULATO_START---([\s\S]*?)---TESTO_RIFORMULATO_END---/im);

                 // Regex per rimuovere etichette di Tono o Livello all'inizio del testo
                 const labelRegex = /^\s*(\*\*?)?(TONO|TONE|FORMAL|FRIENDLY|PROFESSIONAL|CASUAL|SARCASTIC|NEUTRAL|LIVELLO|LEVEL|CEFR|A1|A2|B1|B2|C1|C2)(\*\*?)?\s*[:\(\)-]?\s*\n?/i;

                 if (textMatch && textMatch[1]) {
                    rephrasedText = textMatch[1].trim().replace(labelRegex, ''); // Pulisce eventuali etichette residue
                 } else {
                    // Fallback se i separatori mancano o il parsing fallisce
                    console.warn("Separatore TESTO_RIFORMULATO non trovato o vuoto. Tento fallback sul testo grezzo.");
                    // Prendi tutto il testo prima di ---SPIEGAZIONE_START--- o ---ALTERNATIVE_START---
                    const potentialEndMarkers = /---SPIEGAZIONE_START---|---ALTERNATIVE_START---/im;
                    const endMatchIndex = generatedText.search(potentialEndMarkers);
                     if (endMatchIndex !== -1) {
                        rephrasedText = generatedText.substring(0, endMatchIndex).trim();
                     } else {
                        rephrasedText = generatedText.trim(); // Prendi tutto se nessun altro marcatore è presente
                     }
                     // Pulisci comunque da etichette note
                     rephrasedText = rephrasedText.replace(labelRegex, '');
                     if (!rephrasedText) rephrasedText = "[Errore parsing AI - Testo non trovato]";
                 }


                const expMatch = generatedText.match(/---SPIEGAZIONE_START---([\s\S]*?)---SPIEGAZIONE_END---/im);
                explanation = expMatch ? expMatch[1].trim() : "Spiegazione non trovata o mal formattata.";

                const altMatch = generatedText.match(/---ALTERNATIVE_START---([\s\S]*?)---ALTERNATIVE_END---/im);
                if (altMatch && altMatch[1]) {
                    alternatives = altMatch[1].trim().split('\n')
                        .map(line => line.replace(/^\s*[\d-*•]+\.?\s*/, '').trim()) // Rimuovi numerazione/bullet
                        .map(line => line.replace(labelRegex, '')) // Rimuovi etichette Tono/Livello
                        .filter(line => line.length > 3 && !/^\s*$/.test(line) && !/^(---|\bSPIEGAZIONE\b|\bALTERNATIVE\b|\[\s*Alternativa)/i.test(line)); // Filtri robusti
                } else {
                    alternatives = [];
                     console.warn("Separatore ALTERNATIVE non trovato o vuoto.");
                }

                 // Assicurati ci siano sempre 3 alternative, riempiendo con N/A se necessario
                 while (alternatives.length < 3) alternatives.push("N/A");
                 alternatives = alternatives.slice(0, 3);

                console.log("Parsed Rephrase:", { rephrasedText: rephrasedText.substring(0,100)+"...", explanation, alternatives });
                return {
                    text: rephrasedText,
                    isRephrase: true,
                    tone: tone,
                    explanation: explanation,
                    alternatives: alternatives,
                    cefrLevel: cefrLevel // *** AGGIUNTA: Ritorna il livello usato ***
                };
            } else { // Solo Correzione
                console.log("Parsed Correction:", { text: generatedText.substring(0,100)+"..." });
                 // Pulizia base per sola correzione (rimuove eventuali separatori se l'AI li include per errore)
                 if (/---[A-Z_]+---|\bSPIEGAZIONE:|\bALTERNATIVE:/i.test(generatedText)) {
                    console.warn("Formato inatteso per correzione, applico pulizia base...");
                    generatedText = generatedText.split(/---[A-Z_]+---|\bSPIEGAZIONE:|\bALTERNATIVE:/i)[0].trim();
                 }
                 return {
                    text: generatedText,
                    isRephrase: false,
                    tone: null,
                    explanation: null,
                    alternatives: null,
                    cefrLevel: null // *** AGGIUNTA: Ritorna null ***
                 };
            }
        } catch (error) {
            console.error("Errore chiamata/parsing API:", error);
            // Rilancia l'errore per gestirlo in handleProcessClick
            throw error;
        }
    }


    // --- Funzione Principale ---
    async function handleProcessClick() {
        console.log("+++++ handleProcessClick v12 (CEFR) avviato +++++");
        // Verifica elementi critici e API Key...
        if (!API_KEY || API_KEY.includes("YOUR_API") || API_KEY.length < 20) { handleError("init", new Error("Chiave API mancante/non valida."), true); return; }
        const isAnyActionSelected = proofreadingCheck.checked || rephraseCheck.checked;
        if (!isAnyActionSelected) { showToast(getTranslation('noActionError'), 'bg-yellow-500'); return; }

        try {
            const textToProcess = inputText.value.trim();
            if (!textToProcess) { showToast('Inserisci un testo', 'bg-yellow-500'); return; }

            // Reset UI
            resultsSection.classList.add('hidden');
            if(originalTextHighlighted) originalTextHighlighted.textContent = textToProcess;
            if(correctedText) correctedText.textContent = '';
            if(originalCount) originalCount.textContent = countWords(textToProcess) + ' parole';
            if(correctedCount) correctedCount.textContent = '0 parole';
            hideExpandablePanels();
            setLoadingState(true, 'loading'); // Inizia con "Rilevamento lingua..."

            // Rilevamento Lingua
            let language = 'it'; // Default fallback
            const preferredSetting = preferredLangSelect.value;
            if (preferredSetting === 'auto') {
                language = await detectLanguageWithGeminiAPI(textToProcess);
                console.log("Lingua rilevata (auto):", language);
            } else {
                language = preferredSetting;
                console.log("Lingua selezionata:", language);
            }
             if (!SUPPORTED_LANGS.includes(language)) {
                console.warn(`Lingua rilevata/selezionata '${language}' non supportata, fallback a 'it'.`);
                language = 'it';
             }
            setDetectedLanguageUI(language); // Aggiorna UI lingua
            setLoadingState(true, 'processing'); // Cambia stato in "Elaborazione..."
            console.log(`Chiamo API per elaborare in: ${language} (${getLanguageName(language)})`);

            // Determina opzioni per API
            const useRephrasing = rephraseCheck.checked;
            // La correzione è implicita nella riformulazione nel nuovo prompt, ma la passiamo comunque
            // per determinare il tipo di prompt da usare (proofread vs rephrase)
            const useProofreading = proofreadingCheck.checked;
            console.log("Opzioni REALI per API:", { useProofreading, useRephrasing });

            // Chiamata API
            const result = await processTextWithAI(textToProcess, language, useProofreading, useRephrasing);
            console.log("Risultato AI ricevuto:", { ...result, text: result.text.substring(0, 100) + "..." }); // Logga risultato troncato

             // Estrai dati dal risultato
             const { text: resultText, isRephrase: resultIsRephrase, tone, explanation: explanationText, alternatives, cefrLevel: resultCefrLevel } = result;

            if (!resultText || resultText.trim().length === 0 || resultText.startsWith("[Errore")) {
                 throw new Error(`API ha restituito testo vuoto o un errore interno: ${resultText}`);
            }

            // Visualizzazione Risultati
            resultsSection.classList.remove('hidden');
            correctedText.textContent = resultText; // Mostra testo elaborato
            if (correctedCount) correctedCount.textContent = countWords(resultText) + ' parole';

            // Mostra differenze
            if (typeof Diff !== 'undefined') {
                displayDifferences(textToProcess, resultText, language, resultIsRephrase);
            } else {
                if(originalTextHighlighted) originalTextHighlighted.textContent = textToProcess; // Mostra originale senza highlight
                console.warn("Libreria Diff.js non trovata. Impossibile evidenziare differenze.");
            }

            // Mostra/Nascondi pannelli aggiuntivi
            if (resultIsRephrase) {
                displayRephraseAnalysis(tone, explanationText, alternatives);
                hideCorrectionsPanel(); // Nascondi spiegazioni correzioni se è riformulazione
            } else {
                hideRephraseAnalysisPanel(); // Nascondi analisi riformulazione
                const cl = document.getElementById('corrections-list');
                const ct = correctionsToggleBtn;
                // Mostra bottone correzioni solo se ci sono correzioni listate
                if (cl && ct && cl.children.length > 0) {
                    ct.classList.remove('hidden');
                } else {
                    hideCorrectionsPanel();
                }
            }

            showToast(getTranslation('success'), 'bg-green-500');
            // *** MODIFICA: Passa resultCefrLevel a saveToHistory ***
            saveToHistory(textToProcess, resultText, resultIsRephrase, tone, explanationText, alternatives, resultCefrLevel);
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

        } catch (error) {
            // Gestione centralizzata errori
            handleError('handleProcessClick', error, error.message.includes("Chiave API")); // Mostra alert solo per errori API key
        } finally {
            // Assicura che lo stato di loading sia rimosso
            setLoadingState(false);
        }
    }


    // --- Inizializzazione App ---
    async function initializeApp() {
        console.log("Inizializzazione v12 (CEFR)...");
        // Verifica elementi critici (già fatta all'inizio)

        let initialLangSetting = 'auto';
        try {
            const p = JSON.parse(localStorage.getItem('textai-prefs') || '{}');
            console.log("Preferenze caricate:", p);

            // Carica lingua
            if (p.lang && (SUPPORTED_LANGS.includes(p.lang) || p.lang === 'auto')) {
                initialLangSetting = p.lang;
                console.log("Pref lingua:", initialLangSetting);
            } else { console.log("Nessuna pref lingua valida, uso 'auto'."); }

            // Carica tono
            if (p.tone && defaultToneSelect && [...defaultToneSelect.options].some(o => o.value === p.tone)) {
                defaultToneSelect.value = p.tone;
                console.log("Pref tono:", p.tone);
            }

            // *** AGGIUNTA: Carica livello CEFR ***
            if (p.cefr && cefrLevelSelect && [...cefrLevelSelect.options].some(o => o.value === p.cefr)) {
                cefrLevelSelect.value = p.cefr;
                console.log("Pref CEFR:", p.cefr);
            }

            // Carica stati checkbox
            if (typeof p.proofread === 'boolean' && proofreadingCheck) proofreadingCheck.checked = p.proofread;
            if (typeof p.rephrase === 'boolean' && rephraseCheck) rephraseCheck.checked = p.rephrase;
            if (typeof p.matchStyle === 'boolean' && styleMatchCheck) styleMatchCheck.checked = p.matchStyle;

        } catch(e) {
            console.warn("Impossibile leggere o applicare preferenze:", e);
             localStorage.removeItem('textai-prefs'); // Rimuovi prefs corrotte
        }

        // Applica lingua iniziale all'UI
        if (preferredLangSelect) preferredLangSelect.value = initialLangSetting;
        if (initialLangSetting === 'auto') {
             if(detectedLang) detectedLang.textContent = "Automatico";
        } else {
             setDetectedLanguageUI(initialLangSetting);
        }

        try {
             hideExpandablePanels();
             updateStyleOptionsState(); // Aggiorna stato opzioni stile/livello in base ai checkbox caricati
             updateProcessButtonState(); // Aggiorna stato bottone principale
        } catch (uiError) {
             handleError("initializeApp UI updates", uiError);
        }

        // Imposta testo di default se l'input è vuoto
        if (inputText && !inputText.value) {
             let dT = "";
             // Usa lingua preferita (non auto) o italiano per il testo default
             const langForDefault = (initialLangSetting !== 'auto' && SUPPORTED_LANGS.includes(initialLangSetting)) ? initialLangSetting : 'it';
             switch (langForDefault) {
                 case 'ru': dT = "Привет мир! Как дила? Этот текст содержит ашибки для примера."; break;
                 case 'en': dT = "Helo world! How are you doing? This examples contains some mistaks."; break;
                 case 'es': dT = "Ola mundo! Como estas? Este texo contiene algunos herrores."; break;
                 case 'fr': dT = "Bonjur le monde! Comment ca va? Ce texte contient des érreurs."; break;
                 case 'de': dT = "Hallo Welt! Wie gehts? Dieser Text enthält einige Feler."; break;
                 case 'pt': dT = "Ola mundo! Como voce esta? Este texto contem alguns erros."; break;
                 case 'ar': dT = "مرحباً بالعالم! كيف حالك؟ هذا النص يحتوي على بعض الأخطاء كمثال."; break;
                 case 'it':
                 default: dT = "Qual'è il propiettario di questa casa? Sembra molto bella e avvolte penso di comprarla perchè mi piace.";
              }
              try { inputText.value = dT; console.log("Testo default impostato per:", langForDefault); }
             catch (textErr) { handleError("initializeApp set default text", textErr); }
        } else if (inputText) {
             console.log("Trovato testo esistente nell'input.");
        }

        console.log("Inizializzazione completata.");
    }

    // Avvia l'applicazione
    initializeApp().catch(err => handleError("initializeApp Global", err, true)); // Cattura errori globali init

}); // Fine DOMContentLoaded
</script>            
</body>
</html>
