<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!<!-- Se il file è nella stessa cartella dell'HTML -->
    <script src="jsdiff.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ... (keep all your existing CSS) ... */
        :root {
            --primary: #A5D8FF;
            --secondary: #FFD6A5;
            --accent: #D8A5FF;
            --text: #4A5568;
            --light: #F7FAFC;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #F0F9FF;
            color: var(--text);
        }

        .gradient-bg {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 50%, var(--accent) 100%);
        }

        .text-area {
            min-height: 150px;
            transition: all 0.3s ease;
        }

        .text-area:focus {
            box-shadow: 0 0 0 3px rgba(165, 216, 255, 0.5);
        }

        .btn-primary {
            background-color: var(--primary);
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            background-color: #8BC7FF;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: var(--secondary);
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background-color: #FFC68C;
            transform: translateY(-2px);
        }

        .btn-accent {
            background-color: var(--accent);
            transition: all 0.3s ease;
        }

        .btn-accent:hover {
            background-color: #CA8CFF;
            transform: translateY(-2px);
        }

        .loading-dots::after {
            content: '.';
            animation: dots 1.5s steps(5, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: ''; }
        }

        .slide-in {
            animation: slideIn 0.5s ease-out forwards;
        }

        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* NOTE: The diff styles might not be applicable anymore
           as the API won't return structured changes easily */
        .diff-added {
            background-color: rgba(166, 226, 45, 0.3);
            text-decoration: underline;
        }

        .diff-removed {
            background-color: rgba(255, 129, 130, 0.3);
            text-decoration: line-through;
        }
        .correction-item {
    padding: 8px;
    border-left: 3px solid #FFB86C;
    background-color: rgba(255, 184, 108, 0.1);
    margin-bottom: 8px;
}

.correction-original {
    color: #E53E3E;
    text-decoration: line-through;
    font-weight: 500;
}

.correction-corrected {
    color: #38A169;
    font-weight: 500;
}

.correction-explanation {
    margin-top: 4px;
    font-style: italic;
    color: #4A5568;
}

/* Animazione per l'icona del toggle */
.rotate-icon {
    transform: rotate(180deg);
}

/* Animazione per il pannello */
.slide-down {
    max-height: 500px;
    transition: max-height 0.3s ease-in-out;
}

.slide-up {
    max-height: 0;
    transition: max-height 0.3s ease-in-out;
}
.language-detected {
    animation: flash-detection 1s ease-in-out;
}

@keyframes flash-detection {
    0% { background-color: rgba(165, 216, 255, 0); }
    50% { background-color: rgba(165, 216, 255, 0.5); }
    100% { background-color: rgba(165, 216, 255, 0); }
}

.history-item {
    padding: 10px;
    border-left: 3px solid #D8A5FF;
    background-color: rgba(216, 165, 255, 0.1);
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.history-item:hover {
    background-color: rgba(216, 165, 255, 0.2);
    transform: translateX(3px);
}

.history-date {
    font-size: 0.8rem;
    color: #6B7280;
    margin-bottom: 4px;
}

.history-preview {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9rem;
}

.history-selected {
    border-left-color: #8B5CF6;
    background-color: rgba(139, 92, 246, 0.15);
}


    </style>
</head>
<body class="min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-3xl">
        <!-- Header -->
        <header class="mb-8 text-center">
            <div class="gradient-bg roun-full w-20 h-20 flex items-center justify-center mx-auto mb-4">
                <i class="fas fa-magic text-white text-3xl"></i>
            </div>
            <h1 class="text-3xl font-bold text-gray-800 mb-2">EasyFix (Beta)</h1>
            <p class="text-gray-600">✨ Correggi e riformula i tuoi testi grazie all'intelligenza artificiale</p>
        </header>

        <!-- Main Card -->
        <div class="bg-white rounded-xl shadow-lg overflow-hidden mb-8">
            <!-- Tabs -->
            <div class="flex border-b">
                <button id="text-tab" class="flex-1 py-4 px-6 text-center font-medium text-gray-700 border-b-2 border-blue-500">
                    <i class="fas fa-edit mr-2"></i>Testo
                </button>
                <button id="settings-tab" class="flex-1 py-4 px-6 text-center font-medium text-gray-500">
                    <i class="fas fa-cog mr-2"></i>Impostazioni
                </button>
            </div>

            <div class="mb-6 mt-4">
                <button id="history-toggle" class="w-full flex items-center justify-between p-3 bg-purple-50 text-gray-800 rounded-lg border border-purple-200 hover:bg-purple-100 transition-all">
                    <span class="font-medium">Cronologia correzioni</span>
                    <i class="fas fa-history mr-2"></i>
                    <i class="fas fa-chevron-down transition-transform" id="history-toggle-icon"></i>
                </button>
                <div id="history-panel" class="bg-white p-4 rounded-lg border border-purple-200 mt-2 hidden overflow-hidden">
                    <div class="mb-3 text-sm text-gray-600">
                        <p>Seleziona una correzione precedente per visualizzarla:</p>
                    </div>
                    <div id="history-list" class="max-h-60 overflow-y-auto">
                        <!-- Gli elementi della cronologia verranno inseriti qui dinamicamente -->
                        <p class="text-gray-500 text-sm italic" id="no-history-message">Nessuna correzione precedente disponibile.</p>
                    </div>
                </div>
            </div>

            <!-- Text Tab Content -->
            <div id="text-content" class="p-6">
                <div class="mb-6">
                    <label for="input-text" class="block text-sm font-medium text-gray-700 mb-2">Inserisci il tuo testo</label>
                    <textarea id="input-text" class="text-area w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-200" placeholder="Scrivi o incolla qui il testo da correggere..."></textarea>
                </div>

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Opzioni</label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- Removed detect-lang as API doesn't directly return it easily -->
                        <!-- <div class="flex items-center">
                            <input type="checkbox" id="detect-lang" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" checked>
                            <label for="detect-lang" class="ml-2 block text-sm text-gray-700">Riconoscimento lingua</label>
                        </div> -->
                        <div class="flex items-center">
                            <input type="checkbox" id="proofreading" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" checked>
                            <label for="proofreading" class="ml-2 block text-sm text-gray-700">Correzione grammaticale</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="rephrase" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                            <label for="rephrase" class="ml-2 block text-sm text-gray-700">Riformulazione</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="style-match" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                            <label for="style-match" class="ml-2 block text-sm text-gray-700">Adatta al mio stile</label>
                        </div>
                    </div>
                </div>

                <div class="flex flex-col sm:flex-row gap-4">
                    <button id="process-btn" class="btn-primary flex-1 py-3 px-6 rounded-lg text-white font-medium flex items-center justify-center">
                        <i class="fas fa-spinner fa-spin hidden mr-2" id="processing-spinner"></i>
                        <span id="process-text">Ottimizza il testo</span>
                    </button>
                    <button id="clear-btn" class="btn-secondary py-3 px-6 rounded-lg text-gray-800 font-medium">
                        <i class="fas fa-trash-alt mr-2"></i>Pulisci
                    </button>
                </div>
            </div>            

            <!-- Settings Tab Content -->
            <div id="settings-content" class="p-6 hidden">
                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-900 mb-4">Profilo di scrittura</h3>
                    <div class="mb-4">
                        <label for="writing-style" class="block text-sm font-medium text-gray-700 mb-2">Descrizione del tuo stile</label>
                        <textarea id="writing-style" class="text-area w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-200" placeholder="Es: Uso un tono formale ma amichevole, con frasi brevi e dirette..."></textarea>
                    </div>
                    <div class="mb-4">
                        <label for="sample-text" class="block text-sm font-medium text-gray-700 mb-2">Testo di esempio del tuo stile</label>
                        <textarea id="sample-text" class="text-area w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-200" placeholder="Incolla un testo scritto da te che rappresenta il tuo stile..."></textarea>
                    </div>
                </div>

                <div class="mb-6">
                    <h3 class="text-lg font-medium text-gray-900 dark:text-gray-100 mb-4">Preferenze</h3>
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <span class="flex-grow flex flex-col">
                                <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Lingua preferita</span>
                                <span class="text-xs text-gray-500 dark:text-gray-400">'Automatico' rileva la lingua ad ogni processo</span>
                            </span>
                             <!-- AGGIUNTO 'auto' come PRIMA opzione -->
                            <select id="preferred-lang" class="ml-4 block pl-3 pr-10 py-2 text-base border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100">
                                <option value="auto" selected>Automatico</option>
                                <option value="it">Italiano</option>
                                <option value="en">Inglese</option>
                                <option value="es">Spagnolo</option>
                                <option value="fr">Francese</option>
                                <option value="de">Tedesco</option>
                                <option value="ru">Russo</option>
                                <option value="pt">Portoghese</option>
                                <option value="ar">Arabo</option> <!-- AGGIUNTA LINGUA ARABO -->
                            </select>                                                        
                        </div>
                        

                        <div class="flex items-center justify-between">
                            <span class="flex-grow flex flex-col">
                                <span class="text-sm font-medium text-gray-700">Tono desiderato</span>
                                <span class="text-xs text-gray-500">Per la riformulazione</span>
                            </span>
                            <select id="default-tone" class="ml-4 block pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                                <option value="neutral">Neutrale</option>
                                <option value="formal">Formale</option>
                                <option value="friendly">Amichevole</option>
                                <option value="professional">Professionale</option>
                                <option value="casual">Informale</option>
                                <option value="sarcastic">Sarcastico</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="flex justify-end">
                    <button id="save-settings" class="btn-accent py-2 px-6 rounded-lg text-white font-medium">
                        <i class="fas fa-save mr-2"></i>Salva impostazioni
                    </button>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results-section" class="bg-white rounded-xl shadow-lg overflow-hidden hidden slide-in">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-gray-800">Risultati</h2>
                    <div class="flex items-center">
                        <span class="text-sm text-gray-500 mr-2">Lingua (impostata):</span>
                        <span id="detected-lang" class="px-2 py-1 bg-blue-100 text-blue-800 text-xs font-medium rounded">Italiano</span>
                    </div>
                </div>

                <div class="mb-6">
                    <button id="corrections-toggle" class="w-full flex items-center justify-between p-3 bg-blue-50 text-gray-800 rounded-lg border border-blue-200 hover:bg-blue-100 transition-all">
                        <span class="font-medium">Spiegazione delle correzioni</span>
                        <i class="fas fa-chevron-down transition-transform" id="toggle-icon"></i>
                    </button>
                    <div id="corrections-explanation" class="bg-yellow-50 p-4 rounded-lg border border-yellow-200 mt-2 hidden overflow-hidden">
                        <div id="corrections-list" class="space-y-2 max-h-60 overflow-y-auto text-sm">
                            <!-- Le spiegazioni verranno inserite qui dinamicamente -->
                        </div>
                    </div>
                </div>
                

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label class="block text-sm font-medium text-gray-700">Originale (con modifiche evidenziate)</label>
                            <span id="original-count" class="text-xs text-gray-500">0 parole</span>
                        </div>
                        <!-- Modificato per usare innerHTML per l'evidenziazione -->
                        <div id="original-text-highlighted" class="bg-gray-50 p-4 rounded-lg border border-gray-200 h-64 overflow-y-auto whitespace-pre-wrap"></div>
                    </div>

                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label class="block text-sm font-medium text-gray-700">Elaborato dall'AI</label>
                            <span id="corrected-count" class="text-xs text-gray-500">0 parole</span>
                        </div>
                        <div id="corrected-text" class="bg-blue-50 p-4 rounded-lg border border-blue-200 h-64 overflow-y-auto whitespace-pre-wrap"></div>
                    </div>
                </div>

                <!-- Removed Changes List as it's hard to get structured diffs from the API -->
                <!-- <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Modifiche apportate</label>
                    <div id="changes-list" class="space-y-2 max-h-60 overflow-y-auto">
                         <p class="text-gray-500">La visualizzazione dettagliata delle modifiche non è disponibile con l'API diretta.</p>
                    </div>
                </div> -->

                <div class="flex flex-col sm:flex-row gap-4 mt-6">
                    <button id="copy-btn" class="btn-primary flex-1 py-3 px-6 rounded-lg text-white font-medium">
                        <i class="far fa-copy mr-2"></i>Copia testo elaborato
                    </button>
                    <button id="new-text-btn" class="btn-secondary py-3 px-6 rounded-lg text-gray-800 font-medium">
                        <i class="fas fa-redo mr-2"></i>Nuovo testo
                    </button>
                </div>
            </div>
        </div>

        <!-- Info Section -->
        <div class="mt-8 bg-white rounded-xl shadow-lg overflow-hidden">
             <div class="p-6">
                <h2 class="text-xl font-bold text-gray-800 mb-4">Informazioni su EasyFix</h2>
                <div class="prose prose-sm max-w-none text-gray-600">
                    <p>EasyFix utilizza modelli di linguaggio avanzati di Google AI per aiutarti a perfezionare i tuoi testi. Ecco cosa puoi fare:</p>
                    <ul class="list-disc pl-5 mt-2 space-y-1">
                        <li><strong>Correzione grammaticale e ortografica</strong> - Trova e corregge errori nel testo</li>
                        <li><strong>Riformulazione intelligente</strong> - Riscrivi il testo mantenendo il significato ma migliorando lo stile o cambiando tono</li>
                        <li><strong>Adattamento al tuo stile</strong> - Personalizza la riformulazione in base alle tue preferenze e ai tuoi esempi</li>
                    </ul>
                    <p class="mt-4">EasyFix è progettato per essere semplice e intuitivo, con un'interfaccia pulita che funziona perfettamente su dispositivi mobili e desktop.</p>
                </div>
                <div class="mt-6 text-sm text-gray-500">
                    <span>Creato da Mauro Col - 2025 © <br> versione 0.1 </span>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform translate-y-10 opacity-0 transition-all duration-300 flex items-center">
        <i class="fas fa-check-circle mr-2"></i>
        <span id="toast-message">Operazione completata!</span>
    </div>
    <script>
        // Inserisci questo codice DENTRO il tag <script> alla fine del tuo body HTML
    
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM Caricato. Avvio script EasyFix v11."); // Version bump
    
        // --- Elements ---
        // Verifica critica elementi essenziali
        const textTab = document.getElementById('text-tab');
        const settingsTab = document.getElementById('settings-tab');
        const textContent = document.getElementById('text-content');
        const settingsContent = document.getElementById('settings-content');
        const processBtn = document.getElementById('process-btn');
        const inputText = document.getElementById('input-text');
        const resultsSection = document.getElementById('results-section');
        const correctedText = document.getElementById('corrected-text');
        const historyToggleBtn = document.getElementById('history-toggle');
        const historyPanel = document.getElementById('history-panel');
        const preferredLangSelect = document.getElementById('preferred-lang');
        const defaultToneSelect = document.getElementById('default-tone');
        const proofreadingCheck = document.getElementById('proofreading');
        const rephraseCheck = document.getElementById('rephrase');
        const styleMatchCheck = document.getElementById('style-match');
        const writingStyleInput = document.getElementById('writing-style');
        const sampleTextInput = document.getElementById('sample-text');
    
        // Log e gestione errori se elementi critici mancano
        const essentialUI = { processBtn, inputText, resultsSection, correctedText, textTab, settingsTab, textContent, settingsContent, historyToggleBtn, historyPanel, preferredLangSelect, defaultToneSelect, proofreadingCheck, rephraseCheck, styleMatchCheck, writingStyleInput, sampleTextInput };
        let missingElements = [];
        for (const [name, el] of Object.entries(essentialUI)) {
            if (!el) {
                 console.error(`ERRORE CRITICO AVVIO: Elemento UI essenziale '${name}' NON trovato! Verifica l'ID nell'HTML.`);
                 missingElements.push(name);
            }
        }
        if (missingElements.length > 0) {
            alert(`Errore grave: Impossibile trovare elementi UI essenziali (${missingElements.join(', ')}). L'applicazione potrebbe non funzionare.`);
            return; // Ferma se mancano elementi critici
        }
    
        // Elementi secondari (con check nullità successivi)
        const processingSpinner = document.getElementById('processing-spinner');
        const processText = document.getElementById('process-text');
        const originalTextHighlighted = document.getElementById('original-text-highlighted');
        const detectedLang = document.getElementById('detected-lang');
        const originalCount = document.getElementById('original-count');
        const correctedCount = document.getElementById('corrected-count');
        const clearBtn = document.getElementById('clear-btn');
        const newTextBtn = document.getElementById('new-text-btn');
        const copyBtn = document.getElementById('copy-btn');
        const saveSettings = document.getElementById('save-settings');
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toast-message');
        const correctionsToggleBtn = document.getElementById('corrections-toggle');
        const correctionsExplanationBox = document.getElementById('corrections-explanation');
        const correctionsToggleIcon = document.getElementById('toggle-icon');
        const historyToggleIcon = document.getElementById('history-toggle-icon');
        const styleContainer = document.getElementById('style-options-container'); // ASSICURATI CHE ESISTA!
        const styleDescriptionLabel = document.querySelector('label[for="writing-style"]');
        const styleSampleLabel = document.querySelector('label[for="sample-text"]');
    
        // --- API Configuration ---
        const API_KEY = "AIzaSyDWnH7YEbBDG3Ph5JLbUyZVS_RBSb4uxgs"; // <-- INSERISCI LA TUA CHIAVE API VALIDA QUI
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`;
        const SUPPORTED_LANGS = ['it', 'en', 'es', 'fr', 'de', 'ru', 'pt', 'ar'];
    
        // --- UI Translations ---
        const uiTranslations = { /* ... (invariate v10 - langMismatchError è ERRORE) ... */
            'it': { processBtn: 'Ottimizza il testo', loading: 'Rilevamento lingua...', success: 'Successo!', error: 'Errore', langDetectError: 'Errore rilev. lingua', processing: 'Elaborazione...', langMismatchError: 'Errore: Lingua risultato non valida!', apiKeyError: 'Errore: Chiave API non valida o mancante', networkError: 'Errore di Rete', unknownError: 'Errore Sconosciuto', noActionError: 'Seleziona almeno Correzione o Riformulazione' },
            'en': { processBtn: 'Optimize text', loading: 'Detecting language...', success: 'Success!', error: 'Error', langDetectError: 'Lang detect error', processing: 'Processing...', langMismatchError: 'Error: Invalid result language!', apiKeyError: 'Error: Invalid or missing API Key', networkError: 'Network Error', unknownError: 'Unknown Error', noActionError: 'Select at least Proofreading or Rephrasing' },
            'ru': { processBtn: 'Оптимизировать текст', loading: 'Определение языка...', success: 'Успех!', error: 'Ошибка', langDetectError: 'Ошибка опр. языка', processing: 'Обработка...', langMismatchError: 'Ошибка: Неверный язык результата!', apiKeyError: 'Ошибка: Неверный или отсутствующий ключ API', networkError: 'Сетевая ошибка', unknownError: 'Неизвестная ошибка', noActionError: 'Выберите хотя бы Исправление или Перефразирование' },
            'pt': { processBtn: 'Otimizar texto', loading: 'Detectando idioma...', success: 'Sucesso!', error: 'Erro', langDetectError: 'Erro det. idioma', processing: 'Processando...', langMismatchError: 'Erro: Idioma do resultado inválido!', apiKeyError: 'Erro: Chave de API inválida ou ausente', networkError: 'Erro de Rede', unknownError: 'Erro Desconhecido', noActionError: 'Selecione pelo menos Revisão ou Reformulação' },
            'de': { processBtn: 'Text optimieren', loading: 'Sprache erkennen...', success: 'Erfolg!', error: 'Fehler', langDetectError: 'Spracherk. Fehler', processing: 'Verarbeitung...', langMismatchError: 'Fehler: Ungültige Ergebnissprache!', apiKeyError: 'Fehler: Ungültiger oder fehlender API-Schlüssel', networkError: 'Netzwerkfehler', unknownError: 'Unbekannter Fehler', noActionError: 'Wählen Sie mindestens Korrekturlesen oder Umformulieren' },
            'fr': { processBtn: 'Optimiser le texte', loading: 'Détection langue...', success: 'Succès!', error: 'Erreur', langDetectError: 'Err détec. langue', processing: 'Traitement...', langMismatchError: 'Erreur : Langue du résultat invalide !', apiKeyError: 'Erreur : Clé API invalide ou manquante', networkError: 'Erreur Réseau', unknownError: 'Erreur Inconnue', noActionError: 'Sélectionnez au moins Correction ou Reformulation' },
            'es': { processBtn: 'Optimizar texto', loading: 'Detectando idioma...', success: '¡Éxito!', error: 'Error', langDetectError: 'Error det. idioma', processing: 'Procesando...', langMismatchError: 'Error: ¡Idioma del resultado inválido!', apiKeyError: 'Error: Clave API inválida o faltante', networkError: 'Error de Red', unknownError: 'Error Desconocido', noActionError: 'Seleccione al menos Corrección o Reformulación' },
            'ar': { processBtn: 'تحسين النص', loading: 'اكتشاف اللغة...', success: 'نجاح!', error: 'خطأ', langDetectError: 'خطأ في اكتشاف اللغة', processing: 'معالجة...', langMismatchError: 'خطأ: لغة النتيجة غير صالحة!', apiKeyError: 'خطأ: مفتاح API غير صالح أو مفقود', networkError: 'خطأ في الشبكة', unknownError: 'خطأ غير معروف', noActionError: 'حدد التدقيق اللغوي أو إعادة الصياغة على الأقل' }
        };
    
        // --- Funzioni Helper Generiche (Definite PRIMA del loro uso) ---
        function countWords(t){ return t?.trim()===''?0:t.trim().split(/\s+/).length; }
        function getToneDisplayName(c) { return {formal:'Formale', friendly:'Amichevole', professional:'Professionale', casual:'Informale', sarcastic:'Sarcastico'}[c] || 'Neutrale'; }
        function getLanguageName(c) { return {it:'Italiano', en:'Inglese', es:'Spagnolo', fr:'Francese', de:'Tedesco', ru:'Russo', pt:'Portoghese', ar:'Arabo'}[c] || 'Sconosciuta'; }
        function detectLanguageLocalSimple(t) { /* ... (Funzione invariata, ma non più usata per validazione output) ... */ if (!t) return 'und'; const tl = t.toLowerCase(); if (/[\u0600-\u06FF]/.test(tl)) return 'ar'; if (/[\u0400-\u04FF]/.test(tl)) return 'ru'; if (/[äöüß]/i.test(tl)) return 'de'; if (/[ãõâçêôú]/i.test(tl)) return 'pt'; if (/[ñ¡¿]/i.test(tl)) return 'es'; if (/[àâæçéèêëîïôùûüÿ]/i.test(tl)) return 'fr'; const itM = (tl.match(/\b(il|la|lo|gli|le|del|che|non|sono|hanno|è|per|con|una|si|ciò)\b/g) || []).length; const enM = (tl.match(/\b(the|and|is|are|was|were|have|has|not|for|with|you|that|this|it|of)\b/g) || []).length; if (itM > enM + 2 && itM >= 3) return 'it'; if (enM > itM + 2 && enM >= 3) return 'en'; return 'und'; }
        function calculateWordOverlap(t1, t2) { /* ... (Funzione invariata) ... */ if (!t1 || !t2) return 0; const n = (t) => t.toLowerCase().match(/[\p{L}\p{N}]+/gu) || []; const w1 = new Set(n(t1)); const w2 = new Set(n(t2)); if (w1.size === 0) return w2.size === 0 ? 1 : 0; const i = new Set([...w1].filter(x => w2.has(x))); return w1.size > 0 ? i.size / w1.size : (w2.size === 0 ? 1 : 0); }
        // async function validateResultLanguageStrict(...) { /* Funzione RIMOSSA o COMMENTATA - Non più usata */ }
        function generateExplanation(original, corrected, language) { /* ... (Funzione invariata v10) ... */ const rules = { 'it': { "qual'è": "qual è", "po'": "po’", "perchè": "perché", "sé stesso": "sé stesso", "avvolte":"a volte", "propietario":"proprietario" }, 'ru': { "делаеш": "делаешь", "привет мир":"Привет, мир!", "как дила":"как дела?", "этат":"этот", "ашибками":"ошибками" }, 'en': { "its": "it's", "it's":"its", "your":"you're", "you're":"your", "their":"there", "there":"their", "they're":"their", "helo":"hello", "mistaks":"mistakes", "exemples":"examples"}, 'es': { "ola":"hola", "estas":"estás", "texo":"texto", "herrores":"errores", "como estas":"cómo estás" }, 'fr': { "bonjur":"bonjour", "ca va":"ça va", "érreurs":"erreurs"}, 'de': { "wie gehts":"wie geht's", "feler":"fehler" }, 'pt': { "voce":"você", "esta":"está", "contem":"contém" }, 'ar': {} }; const langRules = rules[language] || {}; const ot = original.trim(); const ct = corrected.trim(); const on = ot.toLowerCase(); const cn = ct.toLowerCase(); for (const [e, f] of Object.entries(langRules)) { if (on === e.toLowerCase() && cn === f.toLowerCase()) { return `Corretto: '${ot}' → '${ct}'.`; } } const ov = calculateWordOverlap(ot, ct); if (on !== cn && Math.abs(ot.length - ct.length) <= 2 && ov > 0.6) return "Correzione ortografica."; if (ot.replace(/\s+/g, '') !== ct.replace(/\s+/g, '')) { const co = on.replace(/[\P{L}\P{N}\s]+/gu, ''); const cc = cn.replace(/[\P{L}\P{N}\s]+/gu, ''); if (co === cc) return "Correzione punteggiatura/spazi."; } if (ov < 0.8 && ov > 0.2) return "Correzione grammaticale / Modifica struttura."; return "Correzione grammaticale/Miglioramento generico."; }
        function getTranslation(key){let cl=preferredLangSelect?preferredLangSelect.value:'auto';if(cl==='auto'){const lcd=Object.keys(uiTranslations).find(c=>getLanguageName(c)===detectedLang?.textContent);cl=lcd||'it';}return uiTranslations[cl]?.[key]||uiTranslations['it']?.[key]||key;}
    
        // --- Funzioni Helper UI (Definite PRIMA del loro uso) ---
        function hideExpandablePanels() { console.log("Nascondo pannelli..."); const ab = document.getElementById('rephrased-analysis-box'); const hp = historyPanel; hideCorrectionsPanel(); if (ab) ab.classList.add('hidden'); if (hp && !hp.classList.contains('hidden')) { hp.classList.add('hidden'); hp.style.maxHeight = '0'; hp.style.padding = '0'; hp.style.marginTop = '0'; hp.style.opacity = '0'; if (historyToggleIcon) historyToggleIcon.classList.remove('rotate-icon'); } }
        function hideCorrectionsPanel() { if (correctionsExplanationBox) { correctionsExplanationBox.classList.add('hidden'); correctionsExplanationBox.style.maxHeight = '0'; correctionsExplanationBox.style.padding = '0'; correctionsExplanationBox.style.marginTop = '0'; correctionsExplanationBox.style.opacity = '0';} if (correctionsToggleBtn) correctionsToggleBtn.classList.add('hidden'); if (correctionsToggleIcon) correctionsToggleIcon.classList.remove('rotate-icon'); }
        function hideRephraseAnalysisPanel() { const ab = document.getElementById('rephrased-analysis-box'); if (ab) ab.classList.add('hidden'); }
        function switchTab(aT,iT,aC,iC){if(!aT||!iT||!aC||!iC){console.error("Err switchTab: elem mancanti.");return;}console.log(`Switch tab: ${aT.id}->${iT.id}`);aT.classList.add('border-blue-500','text-gray-700','dark:text-gray-100');aT.classList.remove('text-gray-500','dark:text-gray-400','border-transparent');iT.classList.add('text-gray-500','dark:text-gray-400','border-transparent');iT.classList.remove('border-blue-500','text-gray-700','dark:text-gray-100');aC.classList.remove('hidden');iC.classList.add('hidden');}
        function showToast(m,bgColor='green-500'){if(!toast||!toastMessage){console.error("Elem Toast mancanti");return;}console.log(`Toast:"${m}" (bg:${bgColor})`);toastMessage.textContent=m;toast.className=toast.className.replace(/bg-(green|red|yellow)-500/g,'')+` bg-${bgColor}`;toast.classList.remove('opacity-0','translate-y-10');toast.classList.add('opacity-100','translate-y-0');if(toast.timeoutId)clearTimeout(toast.timeoutId);toast.timeoutId=setTimeout(()=>{toast.classList.remove('opacity-100','translate-y-0');toast.classList.add('opacity-0','translate-y-10');toast.timeoutId=null;},3500);}
        function updateProcessButtonState() { const isProofreadingActive = proofreadingCheck?.checked ?? false; const isRephrasingActive = rephraseCheck?.checked ?? false; const isActionSelected = isProofreadingActive || isRephrasingActive; if (processBtn) { processBtn.disabled = !isActionSelected; if (!isActionSelected) { processBtn.classList.add('opacity-50', 'cursor-not-allowed'); } else { processBtn.classList.remove('opacity-50', 'cursor-not-allowed'); } } }
        function setLoadingState(isLoading,messageKey='processing'){if(!processingSpinner||!processText||!processBtn){console.error("Elem loading mancanti");return;}const m=getTranslation(messageKey);if(isLoading){console.log(`Loading:TRUE (${m})`);if(processingSpinner)processingSpinner.classList.remove('hidden');if(processText)processText.innerHTML=m+'<span class="loading-dots"></span>';processBtn.disabled=true;processBtn.classList.add('opacity-50','cursor-not-allowed');}else{console.log("Loading:FALSE");if(processingSpinner)processingSpinner.classList.add('hidden');if(processText)processText.textContent=getTranslation('processBtn'); updateProcessButtonState(); /* Aggiorna stato bottone al termine */}}
        function updateStyleOptionsState() {
            const isRephrasing = rephraseCheck?.checked ?? false;
            const enableStyle = isRephrasing;
            console.log(`Aggiornamento opzioni stile: ${enableStyle ? 'Abilitato' : 'Disabilitato'}`);
            if (styleMatchCheck) styleMatchCheck.disabled = !enableStyle;
            if (writingStyleInput) writingStyleInput.disabled = !enableStyle;
            if (sampleTextInput) sampleTextInput.disabled = !enableStyle;
            const elementsToStyle = [styleContainer, styleMatchCheck, writingStyleInput, sampleTextInput, styleDescriptionLabel, styleSampleLabel];
            elementsToStyle.forEach(el => {
                if (!el) return;
                try {
                    if (enableStyle) { el.classList.remove('opacity-50', 'cursor-not-allowed'); if (el === styleContainer) el.classList.remove('opacity-50'); }
                    else { el.classList.add('opacity-50'); if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'BUTTON') { el.classList.add('cursor-not-allowed'); } if (el === styleMatchCheck) el.checked = false; }
                } catch (e) { console.warn(`Errore stile per el: ${el.id || el.tagName}`, e); }
            });
        }
    
        // --- Error Handling (definito DOPO le funzioni UI) ---
        function handleError(context, error, showAlert = false) { console.error(`Errore in ${context}:`, error); let message = error?.message || getTranslation('unknownError'); let specificKeyError = false; let isMismatchError = false; if (message.includes("API key not valid") || message.includes("API_KEY") || (message.includes("400") && (message.includes("API key") || message.includes("api_key")))) { message = getTranslation('apiKeyError'); specificKeyError = true; } else if (message.includes("NetworkError") || message.includes("Failed to fetch") || message.includes("Errore di rete")) { message = getTranslation('networkError'); } else if (message.includes("Lingua risultato non valida") || message.includes("Result language mismatch") || message.includes("Invalid result language")) { message = getTranslation('langMismatchError'); isMismatchError = true; } else if (message.startsWith('Errore API')) { message = `Errore API (${context}): ${message.replace('Errore API ','')}`; } else { message = `${getTranslation('error')} (${context}): ${message}`; } showToast(message, 'red-500'); if (showAlert || specificKeyError) { alert(`ERRORE CRITICO:\n${message}\n\nVerifica chiave API e impostazioni progetto.`); } setLoadingState(false); if (resultsSection) resultsSection.classList.remove('hidden'); if (correctedText) correctedText.textContent = `Errore: ${error.message}`; try { hideExpandablePanels(); } catch(e) { console.error("Errore durante hideExpandablePanels in handleError:", e); } }
    
        // --- Event Listeners (definiti DOPO le funzioni handler) ---
        if (textTab && settingsTab && textContent && settingsContent) { textTab.addEventListener('click', () => switchTab(textTab, settingsTab, textContent, settingsContent)); settingsTab.addEventListener('click', () => switchTab(settingsTab, textTab, settingsContent, textContent)); console.log("Listeners Tab aggiunti."); } else { console.error("Errore critico: Elementi Tab mancanti!"); }
        if (correctionsToggleBtn && correctionsExplanationBox && correctionsToggleIcon) { correctionsToggleBtn.addEventListener('click', function() { /* ... logica toggle ... */ console.log("Corrections Toggle clicked."); correctionsToggleIcon.classList.toggle('rotate-icon'); const iH = correctionsExplanationBox.classList.toggle('hidden'); correctionsExplanationBox.style.transition='max-height .3s ease-out,padding .3s ease-out,margin .3s ease-out,opacity .3s ease-out'; if(!iH){correctionsExplanationBox.style.paddingTop='1rem';correctionsExplanationBox.style.paddingBottom='1rem';correctionsExplanationBox.style.marginTop='.5rem';correctionsExplanationBox.style.opacity='1';correctionsExplanationBox.style.maxHeight=(correctionsExplanationBox.scrollHeight+20)+"px";}else{correctionsExplanationBox.style.maxHeight='0';correctionsExplanationBox.style.paddingTop='0';correctionsExplanationBox.style.paddingBottom='0';correctionsExplanationBox.style.marginTop='0';correctionsExplanationBox.style.opacity='0';} }); console.log("Listener Corrections Toggle aggiunto."); } else { console.warn("Warn: Elementi Corrections Toggle mancanti!"); }
        if (historyToggleBtn && historyPanel && historyToggleIcon) { historyToggleBtn.addEventListener('click', function() { /* ... logica toggle ... */ console.log("History Toggle clicked."); historyToggleIcon.classList.toggle('rotate-icon'); const iH = historyPanel.classList.toggle('hidden'); historyPanel.style.transition='max-height .3s ease-out,padding .3s ease-out,margin .3s ease-out,opacity .3s ease-out'; if(!iH){loadHistoryItems();historyPanel.style.padding='1rem';historyPanel.style.marginTop='.5rem';historyPanel.style.opacity='1';setTimeout(()=>{historyPanel.style.maxHeight='300px';},50);}else{historyPanel.style.maxHeight='0';historyPanel.style.padding='0';historyPanel.style.marginTop='0';historyPanel.style.opacity='0';} }); console.log("Listener History Toggle aggiunto."); } else { console.error("Errore critico: Elementi History Toggle mancanti!"); }
        if (rephraseCheck) { rephraseCheck.addEventListener('change', updateStyleOptionsState); console.log("Listener Rephrase Check (per stile) aggiunto."); } else { console.warn("Warn: rephraseCheck mancante."); }
        if (proofreadingCheck && rephraseCheck && processBtn) { proofreadingCheck.addEventListener('change', updateProcessButtonState); rephraseCheck.addEventListener('change', updateProcessButtonState); console.log("Listeners Checkbox (per bottone) aggiunti."); } else { console.warn("Warn: Checkbox o processBtn mancanti per gestione stato bottone."); }
        if (processBtn) { processBtn.addEventListener('click', handleProcessClick); console.log("Listener Process Button aggiunto."); }
        if (clearBtn) { clearBtn.addEventListener('click', () => { console.log("Clear Button clicked"); if(inputText) inputText.value = ''; if(resultsSection) resultsSection.classList.add('hidden'); if(originalTextHighlighted) originalTextHighlighted.textContent = ''; if(correctedText) correctedText.textContent = ''; if(originalCount) originalCount.textContent = '0 parole'; if(correctedCount) correctedCount.textContent = '0 parole'; hideExpandablePanels(); updateProcessButtonState(); }); console.log("Listener Clear Button aggiunto."); } else { console.warn("Warn: clear-btn mancante."); }
        if (newTextBtn) { newTextBtn.addEventListener('click', () => { console.log("New Text Button clicked"); if(inputText) inputText.value = ''; if(resultsSection) resultsSection.classList.add('hidden'); if(originalTextHighlighted) originalTextHighlighted.textContent = ''; if(correctedText) correctedText.textContent = ''; if(originalCount) originalCount.textContent = '0 parole'; if(correctedCount) correctedCount.textContent = '0 parole'; hideExpandablePanels(); inputText?.focus(); updateProcessButtonState(); }); console.log("Listener New Text Button aggiunto."); } else { console.warn("Warn: new-text-btn mancante."); }
        function copyTextToClipboard(t){if(!t){showToast('Nessun testo da copiare','yellow-500');return;}if(navigator.clipboard&&window.isSecureContext){navigator.clipboard.writeText(t).then(()=>showToast('Testo copiato!')).catch(e=>{console.error("Err Clipboard API:",e);fallbackCopyMethod(t);});}else{fallbackCopyMethod(t);}} function fallbackCopyMethod(t){try{const ta=document.createElement("textarea");ta.value=t;ta.style.position="fixed";ta.style.opacity="0";document.body.appendChild(ta);ta.focus();ta.select();const ok=document.execCommand('copy');document.body.removeChild(ta);if(ok)showToast('Testo copiato!');else showToast('Copia fallita','red-500');}catch(e){handleError("fallbackCopy",e);}} if(copyBtn){copyBtn.addEventListener('click',()=>copyTextToClipboard(correctedText?.textContent||''));console.log("Listener Copy Btn aggiunto.");}else{console.warn("Warn: copy-btn mancante.");}
        if(saveSettings) { saveSettings.addEventListener('click', () => { console.log("Save Settings clicked"); try { const p = { lang: preferredLangSelect?.value || 'auto', tone: defaultToneSelect?.value || 'neutral', proofread: proofreadingCheck?.checked, rephrase: rephraseCheck?.checked, matchStyle: styleMatchCheck?.checked }; localStorage.setItem('textai-prefs', JSON.stringify(p)); showToast('Impostazioni salvate!'); } catch (e) { handleError("saveSettings", new Error("Impossibile salvare preferenze.")); } if (textTab && settingsTab && textContent && settingsContent) { switchTab(textTab, settingsTab, textContent, settingsContent); } }); console.log("Listener Save Settings aggiunto."); } else { console.warn("Warn: save-settings mancante."); }
    
        // --- Funzioni Core (definite DOPO gli helper ma PRIMA delle chiamanti principali)---
        async function detectLanguageWithGeminiAPI(text){console.log("Chiamo API per rilevare lingua...");const pL=preferredLangSelect?(preferredLangSelect.value!=='auto'?preferredLangSelect.value:'it'):'it';if(!API_KEY||API_KEY.includes("YOUR_API")||API_KEY.length<20){console.error("Chiave API mancante/non valida per rilevamento.");return pL;}if(!text||text.trim().length<10){console.log("Testo breve, uso pref:",pL);return pL;}const pr=`Identify the main language (ISO 639-1 code) from [${SUPPORTED_LANGS.join(', ')}] for: "${text.substring(0,500)}"... Respond ONLY with the 2-letter code or 'und'.`;const req={contents:[{parts:[{text:pr}]}],generationConfig:{temperature:0.0,maxOutputTokens:5,stopSequences:["\n"]}};try{const res=await fetch(API_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(req)});if(!res.ok){let eD='';try{const d=await res.json();eD=d?.error?.message||JSON.stringify(d);}catch{eD=await res.text();}console.warn(`Warn API rilevamento (${res.status}): ${eD}. Uso fallback: ${pL}`);return pL;}const data=await res.json();const code=data.candidates?.[0]?.content?.parts?.[0]?.text?.trim().toLowerCase().match(/^[a-z]{2}$/)?.[0];console.log("API rilevato:",code);if(code&&SUPPORTED_LANGS.includes(code))return code;console.warn("Codice API non valido/supportato, fallback a pref:",pL);return pL;}catch(e){console.error("Errore rete rilevamento:",e);console.warn("Uso fallback:",pL);return pL;}}
        function setDetectedLanguageUI(lc){if(!lc||!SUPPORTED_LANGS.includes(lc)){lc='it';}const ln=getLanguageName(lc);if(detectedLang){detectedLang.textContent=ln;detectedLang.classList.remove('language-detected');void detectedLang.offsetWidth;detectedLang.classList.add('language-detected');}if(preferredLangSelect&&preferredLangSelect.value!=='auto'&&preferredLangSelect.value!==lc){console.log(`Aggiorno dropdown (non auto) a: ${lc}`);preferredLangSelect.value=lc;}else if(preferredLangSelect&&preferredLangSelect.value==='auto'&&detectedLang){detectedLang.textContent=`${ln} (Auto)`;}}
        function displayRephraseAnalysis(tone, explanationText, alternatives) { let analysisBox = document.getElementById('rephrased-analysis-box'); if (!analysisBox) { analysisBox = document.createElement('div'); analysisBox.id = 'rephrased-analysis-box'; analysisBox.className = 'bg-blue-50 dark:bg-blue-900/30 border border-blue-300 dark:border-blue-700 rounded-lg p-4 mt-6 mb-8'; analysisBox.innerHTML = `<h3 id="rephrased-analysis-title" class="text-lg font-medium text-blue-800 dark:text-blue-200 mb-3"></h3><div class="mb-4 p-3 bg-white dark:bg-gray-800 rounded-lg border border-blue-200 dark:border-blue-600"><h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Motivazione:</h4><div id="explanation-content" class="text-gray-600 dark:text-gray-400 text-sm"></div></div><div><h4 class="text-md font-medium text-gray-700 dark:text-gray-300 mb-2">Alternative (Stesso Tono):</h4><div id="alternatives-list" class="space-y-2"></div></div>`; if (resultsSection && resultsSection.parentNode) resultsSection.parentNode.insertBefore(analysisBox, resultsSection.nextSibling); else console.error("Impossibile inserire box analisi."); } const analysisTitle = document.getElementById('rephrased-analysis-title'); if (analysisTitle) analysisTitle.textContent = `Analisi Riformulazione (Tono: ${getToneDisplayName(tone)})`; const explanationContent = document.getElementById('explanation-content'); if (explanationContent) explanationContent.textContent = explanationText || "N/A."; const alternativesList = document.getElementById('alternatives-list'); if (alternativesList && alternatives && alternatives.length > 0) { alternativesList.innerHTML = ''; let validAlternativesFound = 0; alternatives.forEach((alternative) => { if (!alternative || alternative.toLowerCase() === "n/a") return; validAlternativesFound++; const item = document.createElement('div'); item.className = 'p-2 bg-gray-50 dark:bg-gray-700 rounded border border-gray-200 dark:border-gray-600 flex justify-between items-center cursor-pointer hover:bg-blue-100 dark:hover:bg-blue-900 transition-colors'; item.dataset.alternativeItem = 'true'; const txt = document.createElement('div'); txt.className = 'flex-grow mr-2 text-sm text-gray-800 dark:text-gray-200'; txt.textContent = alternative; const btn = document.createElement('button'); btn.className = 'text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 text-xs flex items-center flex-shrink-0 ml-2'; btn.innerHTML = `<svg class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2 2H4a2 2 0 01-2-2v-4z"></path></svg> Copia`; btn.addEventListener('click', (e) => { e.stopPropagation(); copyTextToClipboard(alternative); }); item.appendChild(txt); item.appendChild(btn); item.addEventListener('click', () => { if(correctedText) correctedText.textContent = alternative; if(correctedCount) correctedCount.textContent = countWords(alternative) + ' parole'; alternativesList.querySelectorAll('[data-alternative-item="true"]').forEach(i => i.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'border-blue-300', 'dark:border-blue-500')); item.classList.add('bg-blue-100', 'dark:bg-blue-900', 'border-blue-300', 'dark:border-blue-500'); }); alternativesList.appendChild(item); }); if (validAlternativesFound === 0) alternativesList.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">Nessuna alternativa valida.</p>'; } else if (alternativesList) alternativesList.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">N/A.</p>'; if(analysisBox) analysisBox.classList.remove('hidden'); }
        function displayDifferences(original, result, language, isRephraseResult) { const cl = document.getElementById('corrections-list'); const ct = correctionsToggleBtn; if (!cl || !originalTextHighlighted) { console.error("Elementi Diff mancanti"); if(originalTextHighlighted) originalTextHighlighted.textContent = original; return; } cl.innerHTML = ''; let cc = 0; hideCorrectionsPanel(); if (typeof Diff === 'undefined') { if(originalTextHighlighted) originalTextHighlighted.textContent = original; return; } const diff = Diff.diffWords(original, result, { ignoreWhitespace: false }); let oHTML = ''; diff.forEach((p) => { const eV = p.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/\n/g, '<br>'); if (p.removed) { oHTML += `<span class="diff-removed">${eV}</span>`; if (p.added) { if (!isRephraseResult) { let eD = generateExplanation(p.removed, p.added, language); const i = document.createElement('div'); i.className = 'correction-item p-2 border-l-2 border-yellow-400 dark:border-yellow-600 mb-1 bg-yellow-50 dark:bg-yellow-900/20'; i.innerHTML = `<div><span class="correction-original text-red-600 dark:text-red-400 line-through">${p.removed}</span> → <span class="correction-corrected text-green-700 dark:text-green-400 font-medium">${p.added}</span></div><div class="correction-explanation text-xs text-gray-500 dark:text-gray-400 mt-1">${eD}</div>`; cl.appendChild(i); } cc++; } else { if (!isRephraseResult) { const i = document.createElement('div'); i.className = 'correction-item p-2 border-l-2 border-red-400 dark:border-red-600 mb-1 bg-red-50 dark:bg-red-900/20'; i.innerHTML = `<div><span class="correction-original text-red-600 dark:text-red-400 line-through">${p.removed}</span></div><div class="correction-explanation text-xs text-gray-500 dark:text-gray-400 mt-1">Testo rimosso.</div>`; cl.appendChild(i); } cc++; } } else if (p.added) { oHTML += `<span class="diff-added" style="background-color: rgba(16, 185, 129, 0.2); padding: 1px 0;">${eV}</span>`; if (!isRephraseResult) { const i = document.createElement('div'); i.className = 'correction-item p-2 border-l-2 border-green-400 dark:border-green-600 mb-1 bg-green-50 dark:bg-green-900/20'; i.innerHTML = `<div><span class="correction-corrected text-green-700 dark:text-green-400 font-medium">${p.added}</span></div><div class="correction-explanation text-xs text-gray-500 dark:text-gray-400 mt-1">Testo aggiunto.</div>`; cl.appendChild(i); } cc++; } else { oHTML += eV; } }); if (originalTextHighlighted) originalTextHighlighted.innerHTML = oHTML; if (!isRephraseResult && cc > 0) { if(ct) ct.classList.remove('hidden'); } }
        function saveToHistory(ot, ct, ir, t, ex, al) { try { let h = JSON.parse(localStorage.getItem('textai-history') || '[]'); if (!Array.isArray(h)) h = []; const d = h.some(i => i.originalText === ot && i.correctedText === ct && i.isRephrase === ir && i.tone === t); if (!d) { const hi = { id: Date.now(), date: new Date().toLocaleString('it-IT'), originalText: ot, correctedText: ct, isRephrase: ir, tone: t, explanation: ex, alternatives: al, preview: ct.substring(0, 60) + (ct.length > 60 ? '...' : '') }; h.unshift(hi); if (h.length > 15) h = h.slice(0, 15); localStorage.setItem('textai-history', JSON.stringify(h)); console.log("Salvataggio crono:", hi.id); } else { console.log("Duplicato non salvato."); } const hp = historyPanel; if (hp && !hp.classList.contains('hidden')) loadHistoryItems(); } catch (error) { handleError("saveToHistory", error); } }
        function loadHistoryItems() { try { const hl = document.getElementById('history-list'); const nhm = document.getElementById('no-history-message'); if (!hl) { console.error("history-list mancante!"); return; } let h = []; try { h = JSON.parse(localStorage.getItem('textai-history') || '[]'); } catch { console.error("Errore parsing crono"); } if (!Array.isArray(h)) h = []; hl.innerHTML = ''; const msg = nhm || document.getElementById('no-history-message'); if (h.length === 0) { console.log("Crono vuota."); if (msg) { msg.style.display = 'block'; if (!msg.parentNode) hl.appendChild(msg); } else { const n = document.createElement('p'); n.id = 'no-history-message'; n.className = 'text-gray-500 dark:text-gray-400 text-sm italic px-4 py-2'; n.textContent = 'Nessuna correzione.'; hl.appendChild(n); } } else { console.log(`Carico ${h.length} el. crono.`); if (msg) msg.style.display = 'none'; h.forEach(i => { const hi = document.createElement('div'); hi.className = 'history-item p-3 border-b border-gray-200 dark:border-gray-700 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer transition-colors'; hi.dataset.id = i.id; hi.innerHTML = `<div class="text-xs text-gray-500 dark:text-gray-400 mb-1">${i.date}</div><div class="text-sm font-medium text-gray-800 dark:text-gray-200 truncate">${i.isRephrase ? `<span class="text-blue-500 font-semibold">[${getToneDisplayName(i.tone)}]</span> ` : ''}${i.preview}</div>`; hi.addEventListener('click', () => loadHistoryItem(i.id)); hl.appendChild(hi); }); } } catch (error) { handleError("loadHistoryItems", error); } }
        function loadHistoryItem(id) { try { console.log(`Carico crono ID: ${id}`); let h = JSON.parse(localStorage.getItem('textai-history') || '[]'); const i = h.find(it => it.id == id); if (!i) throw new Error("Elem. non trovato"); if (inputText) inputText.value = i.originalText; document.querySelectorAll('.history-item').forEach(el => { el.classList.remove('history-selected', 'bg-blue-100', 'dark:bg-blue-900', 'border-blue-500'); if (el.dataset.id == id) el.classList.add('history-selected', 'bg-blue-100', 'dark:bg-blue-900', 'border-blue-500'); }); handleHistorySelection(i.originalText, i.correctedText, i.isRephrase, i.tone, i.explanation, i.alternatives); } catch (error) { handleError("loadHistoryItem", error); } }
        async function handleHistorySelection(ot, ctv, ir, tn, ex, al) { try { console.log("Visualizzo da crono:", { ir, tn }); hideExpandablePanels(); if(resultsSection) resultsSection.classList.remove('hidden'); if (originalTextHighlighted) originalTextHighlighted.textContent = ot; if (correctedText) correctedText.textContent = ctv; if (originalCount) originalCount.textContent = countWords(ot) + ' parole'; if (correctedCount) correctedCount.textContent = countWords(ctv) + ' parole'; let lang = preferredLangSelect ? (preferredLangSelect.value !== 'auto' ? preferredLangSelect.value : 'it') : 'it'; try { const d = await detectLanguageWithGeminiAPI(ot); if (d) lang = d; } catch {} setDetectedLanguageUI(lang); displayDifferences(ot, ctv, lang, ir); const ab = document.getElementById('rephrased-analysis-box'); const ctg = correctionsToggleBtn; if (ir) { displayRephraseAnalysis(tn, ex, al); if (ab) ab.classList.remove('hidden'); hideCorrectionsPanel(); } else { if (ab) ab.classList.add('hidden'); const cl = document.getElementById('corrections-list'); if (cl && cl.children.length > 0) { if(ctg) ctg.classList.remove('hidden'); } else { hideCorrectionsPanel(); } } } catch (error) { handleError("handleHistorySelection", error); } }
    
        // Funzione per elaborare testo con AI (Prompt v10 - Pulizia Output Rafforzata)
        async function processTextWithAI(text, language, useProofreading, useRephrasing) {
            if (!API_KEY || API_KEY.includes("YOUR_API") || API_KEY.length < 20) throw new Error("Chiave API mancante o non valida.");
            const isStyleMatch = useRephrasing && styleMatchCheck ? styleMatchCheck.checked : false; const styleDesc = useRephrasing && writingStyleInput ? writingStyleInput.value.trim() : '';
            const styleSample = useRephrasing && sampleTextInput ? sampleTextInput.value.trim() : ''; const tone = useRephrasing && defaultToneSelect ? defaultToneSelect.value : 'neutral';
            const langName = getLanguageName(language); console.log("Opzioni effettive Prompt:", { useProofreading, useRephrasing, isStyleMatch, tone });
    
            let promptBase = `Sei un esperto linguista ${langName}.\n\n`; let expectedFormatInstructions = ""; let genConfigParams = {};
    
            if (useRephrasing) {
                // --- PROMPT RIFORMULAZIONE (v7 - Super Esplicito NO ETICHETTE NEL TESTO) ---
                promptBase += `COMPITO: 1) CORREGGI errori, POI 2) RIFORMULA il testo CORRETTO usando SOLO ${langName} (${language}).\nISTRUZIONI IMPERATIVE:\n1. LINGUA: SOLO ${langName.toUpperCase()}.\n2. CORREZIONE: Correggi TUTTI gli errori OGGETTIVI PRIMA.\n3. RIFORMULA + TONO (${tone.toUpperCase()}): APPLICA QUESTO TONO MOLTO EVIDENTEMENTE. Riscrivi profondamente.\n4. SIGNIFICATO: PRESERVA significato e info chiave.\n5. TONI:\n   - Formal: Elevato, impersonale.\n   - Friendly: Caloroso, positivo.\n   - Professional: Chiaro, conciso, autorevole.\n   - Casual: Rilassato, colloquiale.\n   - Sarcastic: IRONIA PESANTE, PALESE.\n   - Neutral: Oggettivo.\n`;
                if (isStyleMatch && (styleDesc || styleSample)) { promptBase += `6. STILE PERSONALE (Prioritario): Descrizione:"${styleDesc}" Esempio:"${styleSample}". COMBINA stile e tono.\n\n`; } else { promptBase += "\n"; }
    
                // **** ISTRUZIONI FORMATO CORRETTE - NO ETICHETTE NEL TESTO! ****
                expectedFormatInstructions = `
    FORMATO RISPOSTA OBBLIGATORIO (USA SEPARATORI ESATTI IN ${langName.toUpperCase()}):\n
    ---TESTO_RIFORMULATO_START---
    [QUI VA **SOLO ED ESCLUSIVAMENTE** il testo principale RIFORMULATO nel tono ${tone.toUpperCase()} richiesto. **IMPORTANTE: NON AGGIUNGERE NESSUNA ETICHETTA** come "${tone.toUpperCase()}:", "**TONO:**" o simili all'inizio di questo blocco. Inizia direttamente con il testo riformulato.]
    ---TESTO_RIFORMULATO_END---
    
    ---SPIEGAZIONE_START---
    [Spiegazione MOLTO BREVE (1-2 frasi) in ${langName} sulle scelte fatte.]
    ---SPIEGAZIONE_END---
    
    ---ALTERNATIVE_START---
    [QUI 3 alternative CONCISE e DIVERSE, TUTTE NEL TONO ${tone.toUpperCase()}. Numera 1. 2. 3. **NON** usare etichette di tono.]
    1. [Alternativa 1 nel tono ${tone.toUpperCase()}]
    2. [Alternativa 2 nel tono ${tone.toUpperCase()}]
    3. [Alternativa 3 nel tono ${tone.toUpperCase()}]
    ---ALTERNATIVE_END---`;
    
                genConfigParams = { temperature: (tone === 'sarcastic') ? 0.98 : 0.9, topP: 0.98, topK: 50 };
            } else if (useProofreading) {
                // --- PROMPT SOLA CORREZIONE (v7 - Stabile) ---
                promptBase += `COMPITO: Correggi SOLO errori oggettivi (gramm/ortog/punt) nel testo ${langName}.\nREGOLE IMPERATIVE:\n1. LINGUA: SOLO ${langName.toUpperCase()} (${language}).\n2. NON MODIFICARE stile, tono, parole, struttura.\n3. NON RIFORMULARE.\n4. CORREZIONI MINIME.\n\n`;
                expectedFormatInstructions = `FORMATO RISPOSTA: SOLO il testo corretto in ${langName}. NIENT'ALTRO.`;
                genConfigParams = { temperature: 0.0, topP: 0.6, topK: 5 };
            } else { throw new Error("Nessuna azione specificata per l'AI."); }
    
            promptBase += `TESTO ORIGINALE (${langName}):\n\`\`\`\n${text}\n\`\`\`\n\nLA TUA RISPOSTA IN ${langName.toUpperCase()} (SEGUI FORMATO):${expectedFormatInstructions}`;
    
            const systemPrompt = promptBase; console.log("Prompt (prime 400):", systemPrompt.substring(0, 400) + "...");
            const requestBody = { contents: [{ parts: [{ text: systemPrompt }] }], generationConfig: { ...genConfigParams, maxOutputTokens: Math.max(350, Math.floor(text.length * (useRephrasing ? 4.0 : 1.5) + 650)) } };
            console.log("Generation Config:", requestBody.generationConfig);
    
            try {
                const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                console.log(`API Status: ${response.status} ${response.statusText}`);
                if (!response.ok) { let eD = `Status: ${response.status}. `; try { const d = await response.json(); eD += d?.error?.message || JSON.stringify(d); } catch { try {eD += await response.text();} catch {} } console.error("API Error Details:", eD); throw new Error(`Errore API. ${eD}`); }
                const data = await response.json(); const candidate = data.candidates?.[0];
                const finishReason = candidate?.finishReason; const blockReason = data.promptFeedback?.blockReason; const safetyRatings = JSON.stringify(candidate?.safetyRatings || data.promptFeedback?.safetyRatings || {});
                 if (blockReason) throw new Error(`Bloccato (${blockReason}). Ratings: ${safetyRatings}`); if (finishReason && finishReason !== "STOP" && finishReason !== "MAX_TOKENS") throw new Error(`Interrotto (${finishReason}). Ratings: ${safetyRatings}`);
                let generatedText = candidate?.content?.parts?.[0]?.text?.trim(); if (!generatedText) throw new Error("Risposta API vuota.");
                console.log("Testo grezzo AI:\n", generatedText);
    
                // **** PARSING CORRETTO E PULIZIA (v7 - Regex Robustissima) ****
                if (useRephrasing) {
                    let rephrasedText = ''; let explanation = ''; let alternatives = [];
                    const textMatch = generatedText.match(/---TESTO_RIFORMULATO_START---([\s\S]*?)---TESTO_RIFORMULATO_END---/im);
    
                    // Estrai e Pulisci etichetta TASSATIVAMENTE usando regex robusta
                    const labelRegex = /^\s*(\*\*?)?(TONO|TONE|FORMAL|FRIENDLY|PROFESSIONAL|CASUAL|SARCASTIC|NEUTRAL)(\*\*?)?\s*:\s*\n?/i;
                    rephrasedText = textMatch ? textMatch[1].trim().replace(labelRegex, '') : '';
    
                    const expMatch = generatedText.match(/---SPIEGAZIONE_START---([\s\S]*?)---SPIEGAZIONE_END---/im); explanation = expMatch ? expMatch[1].trim() : "Spiegazione non formattata.";
    
                    const altMatch = generatedText.match(/---ALTERNATIVE_START---([\s\S]*?)---ALTERNATIVE_END---/im);
                    if (altMatch && altMatch[1]) {
                        alternatives = altMatch[1].trim().split('\n')
                            .map(line => line.replace(/^\s*[\d-*•]+\.?\s*/, '').trim()) // Rimuovi numerazione
                            .map(line => line.replace(labelRegex, '')) // Rimuovi etichette tono (stessa regex)
                            .filter(line => line.length > 3 && !/^\s*$/.test(line) && !/^(---|\bSPIEGAZIONE\b|\bALTERNATIVE\b)/i.test(line)); // Filtri aggiuntivi
                    }
    
                    // Fallback robusto + pulizia aggressiva
                    if (!rephrasedText) {
                        if (!generatedText.includes("---TESTO_RIFORMULATO_START---")) {
                            console.warn("No separatori, uso fallback grezzo e pulisco.");
                            rephrasedText = generatedText.replace(labelRegex, ''); // Pulisci comunque
                            explanation = "Formato non standard."; alternatives = [];
                        } else {
                            console.error("Separatori ma testo vuoto!");
                            rephrasedText = "[Errore formato AI]"; explanation = "Formato errato."; alternatives = [];
                        }
                    }
                     // Pulizia finale per sicurezza
                     rephrasedText = rephrasedText.replace(labelRegex, '');
    
    
                    while (alternatives.length < 3) alternatives.push("N/A"); alternatives = alternatives.slice(0, 3);
                    console.log("Parsed Rephrase:", { rephrasedText, explanation, alternatives });
                    return { text: rephrasedText, isRephrase: true, tone: tone, explanation: explanation, alternatives: alternatives };
                } else { // Solo Correzione
                     console.log("Parsed Correction:", { generatedText });
                     if (/---[A-Z_]+---|\bSPIEGAZIONE:|\bALTERNATIVE:/i.test(generatedText)) { console.warn("Formato inatteso per correzione, pulizia..."); generatedText = generatedText.split(/---[A-Z_]+---|\bSPIEGAZIONE:|\bALTERNATIVE:/i)[0].trim(); }
                     return { text: generatedText, isRephrase: false, tone: null, explanation: null, alternatives: null };
                }
            } catch (error) { console.error("Errore chiamata/parsing API:", error); throw error; }
        }
    
        // --- Funzione Principale (RIMOSSA VALIDAZIONE LINGUA) ---
        async function handleProcessClick() {
            console.log("+++++ handleProcessClick v11 avviato +++++");
            // Verifica elementi critici e API Key...
            if (!API_KEY || API_KEY.includes("YOUR_API") || API_KEY.length < 20) { handleError("init", new Error("Chiave API mancante/non valida."), true); return; }
            const isAnyActionSelected = proofreadingCheck.checked || rephraseCheck.checked;
            if (!isAnyActionSelected) { showToast(getTranslation('noActionError'), 'yellow-500'); return; }
    
            try {
                const textToProcess = inputText.value.trim();
                if (!textToProcess) { showToast('Inserisci un testo', 'yellow-500'); return; }
    
                resultsSection.classList.add('hidden');
                if(originalTextHighlighted) originalTextHighlighted.textContent = textToProcess;
                if(correctedText) correctedText.textContent = '';
                if(originalCount) originalCount.textContent = countWords(textToProcess) + ' parole'; // OK, definita prima
                if(correctedCount) correctedCount.textContent = '0 parole';
                hideExpandablePanels(); setLoadingState(true, 'loading');
    
                let language = 'it'; const preferredSetting = preferredLangSelect.value;
                if (preferredSetting === 'auto') { language = await detectLanguageWithGeminiAPI(textToProcess); console.log("Lingua (auto):", language); }
                else { language = preferredSetting; console.log("Lingua selezionata:", language); }
                setDetectedLanguageUI(language); setLoadingState(true, 'processing');
                console.log(`Chiamo API per elaborare in: ${language} (${getLanguageName(language)})`);
    
                const useRephrasing = rephraseCheck.checked;
                const useProofreading = useRephrasing || proofreadingCheck.checked;
                console.log("Opzioni REALI:", { useProofreading, useRephrasing });
    
                const result = await processTextWithAI(textToProcess, language, useProofreading, useRephrasing);
                console.log("Risultato AI:", result);
                const { text: resultText, isRephrase: resultIsRephrase, tone, explanation: explanationText, alternatives } = result;
                if (!resultText && resultIsRephrase) { throw new Error("Riformulazione API ha restituito testo vuoto."); }
                else if (!resultText) { throw new Error("API non ha restituito testo."); }
    
                // **** VALIDAZIONE LINGUA RIMOSSA ****
                console.log("Validazione lingua output saltata.");
    
                resultsSection.classList.remove('hidden');
                correctedText.textContent = resultText; // Mostra testo pulito
                if (correctedCount) correctedCount.textContent = countWords(resultText) + ' parole';
    
                if (typeof Diff !== 'undefined') { displayDifferences(textToProcess, resultText, language, resultIsRephrase); }
                else { if(originalTextHighlighted) originalTextHighlighted.textContent = textToProcess; console.warn("Diff lib mancante."); }
    
                if (resultIsRephrase) { displayRephraseAnalysis(tone, explanationText, alternatives); hideCorrectionsPanel(); }
                else { hideRephraseAnalysisPanel(); const cl = document.getElementById('corrections-list'); const ct = correctionsToggleBtn; if (cl && ct && cl.children.length > 0) { ct.classList.remove('hidden'); } else { hideCorrectionsPanel(); } }
    
                showToast(getTranslation('success'));
                saveToHistory(textToProcess, resultText, resultIsRephrase, tone, explanationText, alternatives);
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    
            } catch (error) { handleError('handleProcessClick', error); }
            finally { setLoadingState(false); }
        }
    
    
        // --- Inizializzazione App ---
        async function initializeApp() {
            console.log("Inizializzazione v11...");
            // Verifica elementi critici (già fatta all'inizio)
    
            let initialLangSetting = 'auto';
            try {
                const p = JSON.parse(localStorage.getItem('textai-prefs') || '{}');
                if (p.lang && (SUPPORTED_LANGS.includes(p.lang) || p.lang === 'auto')) { initialLangSetting = p.lang; console.log("Pref lingua:", initialLangSetting); } else { console.log("Nessuna pref lingua, uso 'auto'."); }
                if (p.tone && defaultToneSelect && [...defaultToneSelect.options].some(o => o.value === p.tone)) { defaultToneSelect.value = p.tone; console.log("Pref tono:", p.tone); }
                if (typeof p.proofread === 'boolean' && proofreadingCheck) proofreadingCheck.checked = p.proofread;
                if (typeof p.rephrase === 'boolean' && rephraseCheck) rephraseCheck.checked = p.rephrase;
                if (typeof p.matchStyle === 'boolean' && styleMatchCheck) styleMatchCheck.checked = p.matchStyle;
            } catch(e) { console.warn("Impossibile leggere prefs:", e)}
    
            if (preferredLangSelect) preferredLangSelect.value = initialLangSetting;
            if (initialLangSetting === 'auto') { if(detectedLang) detectedLang.textContent = "Automatico"; }
            else { setDetectedLanguageUI(initialLangSetting); }
    
            try {
                 hideExpandablePanels();
                 updateStyleOptionsState();
                 updateProcessButtonState();
            } catch (uiError) { handleError("initializeApp UI updates", uiError); }
    
            // Imposta testo di default (Reso più sicuro)
            if (inputText && !inputText.value) {
                 let dT = ""; const lang = initialLangSetting === 'auto' ? 'it' : initialLangSetting;
                 switch (lang) { /* ... casi lingue ... */
                     case 'ru': dT = "Привет мир! Как дила? Этот текст содержит ашибки для примера."; break; case 'en': dT = "Helo world! How are you doing? This examples contains some mistaks."; break;
                     case 'es': dT = "Ola mundo! Como estas? Este texo contiene algunos herrores."; break; case 'fr': dT = "Bonjur le monde! Comment ca va? Ce texte contient des érreurs."; break;
                     case 'de': dT = "Hallo Welt! Wie gehts? Dieser Text enthält einige Feler."; break; case 'pt': dT = "Ola mundo! Como voce esta? Este texto contem alguns erros."; break;
                     case 'ar': dT = "مرحباً بالعالم! كيف حالك؟ هذا النص يحتوي على بعض الأخطاء كمثال."; break; default: dT = "Qual'è il propiettario di questa casa? Sembra molto bella e avvolte penso di comprarla.";
                  }
                 try { inputText.value = dT; console.log("Testo default impostato per:", lang); }
                 catch (textErr) { handleError("initializeApp set default text", textErr); }
            } else if (inputText) { console.log("Trovato testo esistente."); }
    
            console.log("Inizializzazione completata.");
        }
        initializeApp().catch(err => handleError("initializeApp", err, true)); // Cattura errori globali init
    
    });
    </script>            
</body>
</html>
